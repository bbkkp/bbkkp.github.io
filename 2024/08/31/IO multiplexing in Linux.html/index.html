<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="bbkkp"><meta name="copyright" content="bbkkp"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>Linux下的IO多路复用 | bbkkpの折腾日记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"bbkkp.github.io","root":"/","title":"踏着梦走过时光","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="socket编程前面一部分的统一模板12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F;输入的参数必须是两个，一个是.exe文件名，一个是端口号if (argc &lt; 2)	&#123;		printf(&quot;port error\n&quot;);		return -1;	&#125;		&#x2F;&#x2F;字符串转数字	int p">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux下的IO多路复用">
<meta property="og:url" content="https://bbkkp.github.io/2024/08/31/IO%20multiplexing%20in%20Linux.html/index.html">
<meta property="og:site_name" content="bbkkpの折腾日记">
<meta property="og:description" content="socket编程前面一部分的统一模板12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F;输入的参数必须是两个，一个是.exe文件名，一个是端口号if (argc &lt; 2)	&#123;		printf(&quot;port error\n&quot;);		return -1;	&#125;		&#x2F;&#x2F;字符串转数字	int p">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/16/0MCZNB3k.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/16/XkebXXmM.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/16/XQjHKTuW.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/16/lXzEHai8.png">
<meta property="article:published_time" content="2024-08-31T12:36:14.000Z">
<meta property="article:modified_time" content="2024-08-31T12:36:58.333Z">
<meta property="article:author" content="bbkkp">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="NFS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.imgtp.com/2023/05/16/0MCZNB3k.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="bbkkp"><img width="96" loading="lazy" src="/images/head.jpg" alt="bbkkp"><span class="site-author-status" title="四季花开">☺️</span></a><div class="site-author-name"><a href="/about/">bbkkp</a></div><span class="site-name">bbkkpの折腾日记</span><sub class="site-subtitle">一个人的世界</sub><div class="site-description">踏着梦走过时光</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">68</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">14</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">40</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/bbkkp" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="2094921157@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" target="_blank" rel="noopener" href="https://github.com/bbkkp" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E7%BC%96%E7%A8%8B%E5%89%8D%E9%9D%A2%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E7%BB%9F%E4%B8%80%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.</span> <span class="toc-text">socket编程前面一部分的统一模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%BC%98%E5%8A%BF%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">I&#x2F;O多路复用优势和适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">3.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E4%BA%8Esocket%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">属于socket的连接代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll"><span class="toc-number">5.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll%E8%BF%9E%E6%8E%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">poll连接代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll"><span class="toc-number">7.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-epoll-create-int-size-%EF%BC%9B"><span class="toc-number">7.0.1.</span> <span class="toc-text">int epoll_create(int size)；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event-%EF%BC%9B"><span class="toc-number">7.0.2.</span> <span class="toc-text">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><span class="toc-number">7.0.3.</span> <span class="toc-text">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">epoll工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">epoll总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">10.</span> <span class="toc-text">监听套接字为什么非阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8recv%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">11.</span> <span class="toc-text">为什么用recv读数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll%E7%9A%84%E5%86%85%E6%A0%B8%E5%BA%95%E5%B1%82%E6%98%AF%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">12.</span> <span class="toc-text">poll的内核底层是一个链表</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://bbkkp.github.io/2024/08/31/IO%20multiplexing%20in%20Linux.html/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="bbkkp"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="bbkkpの折腾日记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Linux下的IO多路复用</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2024-08-31 20:36:14" itemprop="dateCreated datePublished" datetime="2024-08-31T20:36:14+08:00">2024-08-31</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Linux/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Linux</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/Linux/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">Linux</span></a><a class="tag-item" href="/tags/NFS/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">NFS</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="socket编程前面一部分的统一模板"><a href="#socket编程前面一部分的统一模板" class="headerlink" title="socket编程前面一部分的统一模板"></a>socket编程前面一部分的统一模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入的参数必须是两个，一个是.exe文件名，一个是端口号</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;port error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//字符串转数字</span></span><br><span class="line">	<span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//socket 协议族 IPv4  Socket类型 面相连接 指定协议 自动选择</span></span><br><span class="line">	<span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//bind</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	<span class="comment">//16位整数主机字节序转网络字节序</span></span><br><span class="line">	<span class="comment">//小端转大端</span></span><br><span class="line">	addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">	addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	<span class="comment">//他可以转换成它，也必须转换，不然编译错误，这么做是因为它更简单易用</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;bind\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(sockfd, <span class="number">5</span>) &lt; <span class="number">0</span>)<span class="comment">//5是全连接队列的长度</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;listen\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="I-O多路复用优势和适用场景"><a href="#I-O多路复用优势和适用场景" class="headerlink" title="I&#x2F;O多路复用优势和适用场景"></a>I&#x2F;O多路复用优势和适用场景</h2><blockquote>
<p>本质上还是同步IO,IO多路复用的优势在于，当处理任务的消耗对比IO几乎可以忽略不计时，可以处理大量的并发IO，而不用消耗太多CPU&#x2F;内存。IO多路复用适合处理很多闲置IO的情况，因为IO socket的数量的增加并不会带来进（线）程数的增加。也就不会带来栈内存，内核对象，线程上下文切换时间的损耗。</p>
</blockquote>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>单个进程能够监视的文件描述符的数量存在最大限制，它由FD_SETSIZE设置，默认值是1024。</li>
<li>fd集合在内核被置位过，与传入的fd集合不同，不可重用。每次重新while()循环都要通过之前的准备的另一个置位了自己的socket描述符的fd集合重新复位。这是它自己本质只是一个1024位的位数组</li>
<li>每次调⽤用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大。</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd标志位，O(n)的时间复杂度，这个开销在fd很多时也很大。即使每次遍历的时候会用到max开销依旧很大</li>
</ul>
<h2 id="属于socket的连接代码"><a href="#属于socket的连接代码" class="headerlink" title="属于socket的连接代码"></a>属于socket的连接代码</h2><p><img src="https://img1.imgtp.com/2023/05/16/0MCZNB3k.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/16/XkebXXmM.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/16/XQjHKTuW.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/16/lXzEHai8.png" alt="image" loading="lazy"></p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><blockquote>
<p>pollfd结构</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; 		</span><br><span class="line">    <span class="comment">//读 POLLIN; 写POLLOUT;</span></span><br><span class="line">    <span class="type">short</span> events;   要监视的event*/</span><br><span class="line">    <span class="type">short</span> revents;   发生的event*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>poll用pollfd数组代替了bitmap，没有最大数量限制。</li>
<li>利用结构体pollfd，每次置位revents字段，每次只需恢复revents即可。pollfd可重用。</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>每次调⽤用poll，都需要把pollfd数组从用户态拷贝到内核态，这个开销在fd很多时会很大。</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd标志位，O(n)的时间复杂度，这个开销在fd很多时也很大</li>
</ul>
<h2 id="poll连接代码"><a href="#poll连接代码" class="headerlink" title="poll连接代码"></a>poll连接代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">POLL_SIZE</span>] =</span> &#123;<span class="number">0</span>&#125;;<span class="comment">//POLL_SIZE随便设大小</span></span><br><span class="line"><span class="comment">//第一当然是本地套接字，读事件</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"><span class="type">int</span> maxfd = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//其他的描述符都置-1</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; POLL_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nready = poll(fds, maxfd, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (POLLIN == (fds[<span class="number">0</span>].revents &amp; POLLIN))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">		<span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">		<span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> clientfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> &gt; clientfd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> str[INET_ADDRSTRLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;recvived from %s at port %d, sockfd:%d, clientfd:%d\n&quot;</span>,</span><br><span class="line">			inet_ntop(AF_INET, &amp;client_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">			ntohs(client_addr.sin_port),</span><br><span class="line">			sockfd,</span><br><span class="line">			clientfd);</span><br><span class="line">           <span class="comment">//添加进数组</span></span><br><span class="line">		fds[clientfd].fd = clientfd;</span><br><span class="line">		fds[clientfd].events = POLLIN;</span><br><span class="line">           <span class="comment">//更新maxfd</span></span><br><span class="line">		<span class="keyword">if</span> (clientfd &gt;= maxfd)</span><br><span class="line">		&#123;</span><br><span class="line">			maxfd = clientfd + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (--nready == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i &lt; maxfd; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fds[i].revents &amp; (POLLIN|POLLERR))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> buffer[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="type">int</span> ret = recv(i, buffer, BUF_LEN, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;read all data\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					close(i);</span><br><span class="line">					fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">if</span> (i == maxfd - <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						maxfd--;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;disconnect %d\n&quot;</span>, i);</span><br><span class="line">				</span><br><span class="line">				close(i);</span><br><span class="line">				fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span> (i == maxfd - <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					maxfd--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;recv: %s, %d Bytes\n&quot;</span>, buffer, ret);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (--nready == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><h4 id="int-epoll-create-int-size-；"><a href="#int-epoll-create-int-size-；" class="headerlink" title="int epoll_create(int size)；"></a>int epoll_create(int size)；</h4><p>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
<blockquote>
<p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 红黑树的根节点，这棵树中存储着所有添加到epoll中的需要监控的事件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line">    <span class="comment">// 双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</li>
<li>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</li>
</ul>
<h4 id="int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event-；"><a href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event-；" class="headerlink" title="int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；"></a>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</h4><ul>
<li>函数是对指定描述符fd执行op操作。<br>用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">  <span class="type">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示 :</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;       <span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink; <span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">wpoll_filefd</span> ffd;  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evntpoll</span> *ep;	  <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event; <span class="comment">//期待发生的事件类型   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户 。</p>
</blockquote>
<h4 id="int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);"></a>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</h4><ul>
<li>等待epfd上的io事件，最多返回maxevents个事件。<br>通过回调函数内核会将 I&#x2F;O 准备好的描述符添加到rdlist双链表管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li>
</ul>
<h2 id="epoll工作模式"><a href="#epoll工作模式" class="headerlink" title="epoll工作模式"></a>epoll工作模式</h2><blockquote>
<p>epoll对文件描述符的操作有两种模式：LT (level trigger)（默认）和ET (edge trigger)。LT模式是默认模式。</p>
</blockquote>
<ul>
<li>LT模式与ET模式的区别如下：<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
</li>
<li>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</li>
<li>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)<br>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
<h2 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h2><blockquote>
<p>在 select&#x2F;poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuotian/p/13199625.html">https://www.cnblogs.com/kuotian/p/13199625.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37158051/article/details/110674644">https://blog.csdn.net/qq_37158051/article/details/110674644</a></p>
</blockquote>
<h2 id="监听套接字为什么非阻塞"><a href="#监听套接字为什么非阻塞" class="headerlink" title="监听套接字为什么非阻塞"></a>监听套接字为什么非阻塞</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xp178171640/article/details/105944038">https://blog.csdn.net/xp178171640/article/details/105944038</a></p>
</blockquote>
<h2 id="为什么用recv读数据"><a href="#为什么用recv读数据" class="headerlink" title="为什么用recv读数据"></a>为什么用recv读数据</h2><blockquote>
<p>第四个参数可以处理流失协议下客户端数据无法一次发完，服务端页读不到指定长度的数据，就在哪耗着，直到读到。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hhhlizhao/article/details/73912578">https://blog.csdn.net/hhhlizhao/article/details/73912578</a></p>
</blockquote>
<h2 id="poll的内核底层是一个链表"><a href="#poll的内核底层是一个链表" class="headerlink" title="poll的内核底层是一个链表"></a>poll的内核底层是一个链表</h2></div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>bbkkp</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://bbkkp.github.io/2024/08/31/IO%20multiplexing%20in%20Linux.html/" title="Linux下的IO多路复用">https://bbkkp.github.io/2024/08/31/IO%20multiplexing%20in%20Linux.html/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2024/08/31/tmux.html/" rel="prev" title="tmux"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">tmux</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2024/08/31/2024%20Latest%20How%20to%20download%20a%20folder%20from%20project%20on%20github.html/" rel="next" title="2024最新如何从github上下载某个项目中某个文件夹"><span class="post-nav-text">2024最新如何从github上下载某个项目中某个文件夹</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2024 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> bbkkp</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div><div class="live-time"><span>感谢陪伴</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2024-08-30T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div><div class="footer-custom-text"><a href="yourLink" rel="noopener" target="_blank">学就完了</a></div><div class="footer-support"><span>本站由</span><a class="footer-support-logo" href="https://www.rainyun.com/YeMeng_" target="blank" title="雨云"><img height="30" src="https://cn-sy1.rains3.com/yemenghexo/rainyunlogo.png" alt="雨云"></a><span>提供 对象存储 服务</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>