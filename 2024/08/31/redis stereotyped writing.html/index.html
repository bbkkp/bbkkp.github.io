<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="bbkkp"><meta name="copyright" content="bbkkp"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>redis八股文 | bbkkpの折腾日记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"bbkkp.github.io","root":"/","title":"踏着梦走过时光","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="什么是redis Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。提供了多种数据类型，且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。  Redis 和 Memcached 有什么区别 相同基于内存，常被当做缓存读写性能非常高都有过期策略   不相同支持多种数据类型;只支持key-va">
<meta property="og:type" content="article">
<meta property="og:title" content="redis八股文">
<meta property="og:url" content="https://bbkkp.github.io/2024/08/31/redis%20stereotyped%20writing.html/index.html">
<meta property="og:site_name" content="bbkkpの折腾日记">
<meta property="og:description" content="什么是redis Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。提供了多种数据类型，且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。  Redis 和 Memcached 有什么区别 相同基于内存，常被当做缓存读写性能非常高都有过期策略   不相同支持多种数据类型;只支持key-va">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.imgtp.com/2023/04/25/IRmorhyQ.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/04/25/IRmorhyQ.png">
<meta property="article:published_time" content="2024-08-31T14:00:33.000Z">
<meta property="article:modified_time" content="2024-08-31T14:15:37.593Z">
<meta property="article:author" content="bbkkp">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.imgtp.com/2023/04/25/IRmorhyQ.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="bbkkp"><img width="96" loading="lazy" src="/images/head.jpg" alt="bbkkp"><span class="site-author-status" title="四季花开">☺️</span></a><div class="site-author-name"><a href="/about/">bbkkp</a></div><span class="site-name">bbkkpの折腾日记</span><sub class="site-subtitle">一个人的世界</sub><div class="site-description">踏着梦走过时光</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">68</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">14</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">40</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/bbkkp" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="2094921157@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" target="_blank" rel="noopener" href="https://github.com/bbkkp" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFredis"><span class="toc-number">1.</span> <span class="toc-text">什么是redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%92%8C-Memcached-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">Redis 和 Memcached 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-Redis-%E4%BD%9C%E4%B8%BA-MySQL-%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">为什么用 Redis 作为 MySQL 的缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">4.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-number">5.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash"><span class="toc-number">6.</span> <span class="toc-text">hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">7.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zset"><span class="toc-number">8.</span> <span class="toc-text">zset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bitmaps"><span class="toc-number">9.</span> <span class="toc-text">bitmaps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">10.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geospatial"><span class="toc-number">11.</span> <span class="toc-text">Geospatial</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stream"><span class="toc-number">12.</span> <span class="toc-text">stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%9F%BA%E4%BA%8E-Stream-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E4%B8%93%E4%B8%9A%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E8%B7%9D%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">Redis 发布&#x2F;订阅机制为什么不可以作为消息队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">redis的单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis6-0%E4%B9%8B%E5%89%8D-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">16.</span> <span class="toc-text">Redis6.0之前 单线程模式是怎样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">Redis 采用单线程为什么还这么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">Redis 6.0 之后为什么引入了多线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">Redis 如何实现数据不丢失？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-%E6%97%A5%E5%BF%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">AOF 日志是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%86%8D%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97%E5%91%A2%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">为什么先执行命令，再把数据写入日志呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%86%99%E5%85%A5-AOF-%E6%97%A5%E5%BF%97%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">Redis 写入 AOF 日志的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">AOF 写回策略有几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-%E6%97%A5%E5%BF%97%E8%BF%87%E5%A4%A7%EF%BC%8C%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">AOF 日志过大，会触发什么机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99-AOF-%E6%97%A5%E5%BF%97%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">重写 AOF 日志的过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-%E5%BF%AB%E7%85%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">RDB 快照是如何实现的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-%E5%81%9A%E5%BF%AB%E7%85%A7%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">RDB 做快照时会阻塞线程吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%85%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%83%BD%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">RDB 在执行快照的时候，数据能修改吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">为什么会有混合持久化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">30.</span> <span class="toc-text">混合持久化是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E4%BC%98%E7%82%B9"><span class="toc-number">31.</span> <span class="toc-text">混合持久化优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E7%BC%BA%E7%82%B9"><span class="toc-number">32.</span> <span class="toc-text">混合持久化缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">33.</span> <span class="toc-text">实现服务高可用-主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A1%AE%E5%AE%9A%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">34.</span> <span class="toc-text">第一次同步数据和确定主从服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%AE%8C%E6%88%90%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%9F%BA%E4%BA%8E%E5%91%BD%E4%BB%A4%E7%9A%84TCP%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">35.</span> <span class="toc-text">主从服务器在完成第一次同步后的数据一致性基于命令的TCP长连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%91%8A%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8E%8B%E5%8A%9B"><span class="toc-number">36.</span> <span class="toc-text">分摊主服务器的压力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%96%AD%E5%BC%80%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">37.</span> <span class="toc-text">网络断开增量复制的三个步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%A6%81%E5%B0%86%E5%93%AA%E4%BA%9B%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E7%BB%99%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">主服务器怎么知道要将哪些增量数据发送给从服务器呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E6%97%B6%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%BF%98%E6%98%AF%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">Redis主从节点时长连接还是短连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD-Redis-%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">怎么判断 Redis 某个节点是否正常工作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84%E4%B8%AD%EF%BC%8C%E8%BF%87%E6%9C%9Fkey%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">主从复制架构中，过期key如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8unlink"><span class="toc-number">42.</span> <span class="toc-text">为什么不用unlink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B8%BB%E8%8A%82%E7%82%B9%E6%AF%8F%E6%AC%A1%E6%94%B6%E5%88%B0%E5%86%99%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%85%88%E5%86%99%E5%88%B0%E5%86%85%E9%83%A8%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E7%84%B6%E5%90%8E%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E7%BB%99%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="toc-number">43.</span> <span class="toc-text">Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%AD%E4%B8%A4%E4%B8%AA-Buffer-replication-buffer-%E3%80%81repl-backlog-buffer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">如何如何应对主从数据不一致？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">主从切换如何减少数据丢失？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">主从如何做到故障自动切换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9C%9F%E7%9A%84%E6%95%85%E9%9A%9C%E4%BA%86%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">哨兵机制如何判断主节点真的故障了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B1%E5%93%AA%E4%B8%AA%E5%93%A8%E5%85%B5%E8%BF%9B%E8%A1%8C%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">由哪个哨兵进行主从故障转移？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">主从故障转移的过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">51.</span> <span class="toc-text">主从复制和切片集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1%E9%97%AE%E9%A2%98"><span class="toc-number">52.</span> <span class="toc-text">请求路由问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="toc-number">53.</span> <span class="toc-text">数据迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B9%8B%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">54.</span> <span class="toc-text">过期删除策略之惰性删除策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B9%8B%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">55.</span> <span class="toc-text">过期删除策略之定期删除策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">56.</span> <span class="toc-text">过期删除策略之定时删除策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">如何设置过期时间？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%97%B6%EF%BC%8C%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">Redis 持久化时，对过期键会如何处理的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">Redis 主从模式中，对过期键会如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">Redis 内存满了，会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E4%B8%A4%E7%B1%BB"><span class="toc-number">61.</span> <span class="toc-text">八种两类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-LRU-%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">什么是 LRU 算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-LRU-%E7%AE%97%E6%B3%95%E7%9A%84%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">Redis 是如何实现 LRU 算法的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-LFU-%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">什么是 LFU 算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-LFU-%E7%AE%97%E6%B3%95%E7%9A%84%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">Redis 是如何实现 LFU 算法的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F-redis%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98"><span class="toc-number">66.</span> <span class="toc-text">如何避免缓存雪崩？(redis作为数据库缓存)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">如何避免缓存击穿？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">如何避免缓存穿透？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%91%A2%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">如何设计一个缓存策略，可以动态缓存热点数据呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%92%8C-MySQL-%E7%9A%84%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">70.</span> <span class="toc-text">Redis 和 MySQL 的缓存更新策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read-Write-Through%EF%BC%88%E8%AF%BB%E7%A9%BF-%E5%86%99%E7%A9%BF%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">71.</span> <span class="toc-text">Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Write-Back%EF%BC%88%E5%86%99%E5%9B%9E%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">72.</span> <span class="toc-text">Write Back（写回）策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">Redis 如何实现延迟队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redis-%E5%A4%A7-key%EF%BC%9F"><span class="toc-number">74.</span> <span class="toc-text">什么是 Redis 大 key？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7-key-%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">75.</span> <span class="toc-text">大 key 会造成什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%A7-key-%EF%BC%9F"><span class="toc-number">76.</span> <span class="toc-text">如何找到大 key ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%A4%A7-key%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">如何删除大 key？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%AE%A1%E9%81%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">78.</span> <span class="toc-text">Redis 管道有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%E5%90%97%EF%BC%9F"><span class="toc-number">79.</span> <span class="toc-text">Redis 事务支持回滚吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">80.</span> <span class="toc-text">集群方案</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://bbkkp.github.io/2024/08/31/redis%20stereotyped%20writing.html/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="bbkkp"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="bbkkpの折腾日记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">redis八股文</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2024-08-31 22:00:33" itemprop="dateCreated datePublished" datetime="2024-08-31T22:00:33+08:00">2024-08-31</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">八股文</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/redis/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">redis</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><blockquote>
<p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。提供了多种数据类型，且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p>
</blockquote>
<h2 id="Redis-和-Memcached-有什么区别"><a href="#Redis-和-Memcached-有什么区别" class="headerlink" title="Redis 和 Memcached 有什么区别"></a>Redis 和 Memcached 有什么区别</h2><blockquote>
<p>相同<br>基于内存，常被当做缓存<br>读写性能非常高<br>都有过期策略</p>
</blockquote>
<blockquote>
<p>不相同<br>支持多种数据类型;只支持key-value<br>支持数据持久化;不支持</p>
</blockquote>
<h2 id="为什么用-Redis-作为-MySQL-的缓存？"><a href="#为什么用-Redis-作为-MySQL-的缓存？" class="headerlink" title="为什么用 Redis 作为 MySQL 的缓存？"></a>为什么用 Redis 作为 MySQL 的缓存？</h2><blockquote>
<p>高性能，高并发</p>
</blockquote>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><blockquote>
<p>key-value 最大512M<br>数字或者字符串<br>简单动态字符串与c字符串区别 安全自动扩容，获取长度o(1)<br>编码模式 int ,embstr,raw 44,浮点数也是字符串<br>embstr相比raw的优缺点<br>缓存对象，常规计数，共享session,结合lua脚本完成分布式锁</p>
</blockquote>
<blockquote>
</blockquote>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><blockquote>
<p>2^32 - 1 快速列表 双向循环列表和压缩列表的结合，每一个节点都是一个压缩列表<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/12624691.html(%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8)">https://www.cnblogs.com/hunternet/p/12624691.html(快速列表)</a><br>消息队列<br>消息的存取<br>l&#x2F;rpush br&#x2F;lpop<br>处理重复消息<br>消费者自行生成全局唯一ID<br>保证消息可靠性<br>消费者出现故障和宕机，备份List,BRPOPLPUSH</p>
</blockquote>
<blockquote>
<p>缺点<br>不支持消费组</p>
</blockquote>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><blockquote>
<p>key-key:value<br>listpack 和hash<br>如果小于512且每个小于64字节 则Listpack,反之则hash<br>缓存对象，购物车</p>
</blockquote>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><blockquote>
<p>都是整数且小于512个则整数集合<br>不然就hash key-key:null<br>点赞，抽奖，共同关注</p>
</blockquote>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><blockquote>
<p>x小于128且都小于64字节 listpack<br>不然hash key-key:socre<br>排行榜，电话姓名排序<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Appleeatingboy/article/details/119948340(%E8%B7%B3%E8%A1%A8)">https://blog.csdn.net/Appleeatingboy/article/details/119948340(跳表)</a></p>
</blockquote>
<h2 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h2><blockquote>
<p>底层就是一个二进制字符串<br>适合二值统计<br>签到统计，判断用户是否登录，连续签到用户总数</p>
</blockquote>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote>
<p>话费12kb的内存进行百万级网页UV的不精确去重计数</p>
</blockquote>
<h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><blockquote>
<p>底层就是有序集合<br>滴滴打车</p>
</blockquote>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><blockquote>
<p>XGROUP 创建消费组，不同消费组中的消费者可以读取统一条消息，同一个消费组可以均衡读取消息，消息ID系统自动生成系统时间，也可以指定，系统时间修改逆转，最小-x加个一。</p>
</blockquote>
<blockquote>
<p>消息可靠性：内部使用 PENDING List 自动保存消息，使用 XPENDING 命令查看消费组已经读取但是未被确认的消息，消费者使用 XACK 确认消息.</p>
</blockquote>
<blockquote>
<p>xadd xread block消息报序阻塞读取</p>
</blockquote>
<h2 id="Redis-基于-Stream-消息队列与专业的消息队列有哪些差距？"><a href="#Redis-基于-Stream-消息队列与专业的消息队列有哪些差距？" class="headerlink" title="Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？"></a>Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？</h2><blockquote>
<p>MQ中间件无法保证数据不丢失<br>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能<br>主从复制也是异步的，主从切换时，也存在丢失数据的可能</p>
</blockquote>
<p>RabbitMQ 或 Kafka 集群</p>
<blockquote>
<p>无法保证消息可堆积<br>内存中消息队列过大被OOM，限定大小旧消息被删除</p>
</blockquote>
<p>RabbitMQ 或 Kafka 磁盘</p>
<h2 id="Redis-发布-订阅机制为什么不可以作为消息队列？"><a href="#Redis-发布-订阅机制为什么不可以作为消息队列？" class="headerlink" title="Redis 发布&#x2F;订阅机制为什么不可以作为消息队列？"></a>Redis 发布&#x2F;订阅机制为什么不可以作为消息队列？</h2><blockquote>
<p>发布&#x2F;订阅机制没有基于任何数据类型实现，所以不具备「数据持久化」的能力，也就是发布&#x2F;订阅机制的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，发布&#x2F;订阅机制的数据也会全部丢失。<br>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。<br>当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开<br>所以，发布&#x2F;订阅机制只适合即时通讯的场景，比如构建哨兵集群 (opens new window)的场景采用了发布&#x2F;订阅机制。</p>
</blockquote>
<h2 id="redis的单线程"><a href="#redis的单线程" class="headerlink" title="redis的单线程"></a>redis的单线程</h2><blockquote>
<p>执行命令是单线程的，Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</p>
</blockquote>
<blockquote>
<p>Redis 程序并不是单线程的,会在启动时启动三个后台线程，分别用于异步关闭文件，AOF刷盘和释放内存</p>
</blockquote>
<h2 id="Redis6-0之前-单线程模式是怎样的"><a href="#Redis6-0之前-单线程模式是怎样的" class="headerlink" title="Redis6.0之前 单线程模式是怎样的"></a>Redis6.0之前 单线程模式是怎样的</h2><blockquote>
<p>主要是epoll的IO端口复用</p>
</blockquote>
<h2 id="Redis-采用单线程为什么还这么快？"><a href="#Redis-采用单线程为什么还这么快？" class="headerlink" title="Redis 采用单线程为什么还这么快？"></a>Redis 采用单线程为什么还这么快？</h2><blockquote>
<p>内存中读写，高效数据结构，瓶颈是内存和网络带宽不是cpu,不需要使用多线程</p>
</blockquote>
<blockquote>
<p>单线程避免线程 切换的开销和并发竞争与死锁</p>
</blockquote>
<h2 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h2><blockquote>
<p>提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理</p>
</blockquote>
<h2 id="Redis-如何实现数据不丢失？"><a href="#Redis-如何实现数据不丢失？" class="headerlink" title="Redis 如何实现数据不丢失？"></a>Redis 如何实现数据不丢失？</h2><blockquote>
<p>AOF日志<br>RDB快照<br>混合持久化方式</p>
</blockquote>
<h2 id="AOF-日志是如何实现的？"><a href="#AOF-日志是如何实现的？" class="headerlink" title="AOF 日志是如何实现的？"></a>AOF 日志是如何实现的？</h2><blockquote>
<p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢<del>复。</del></p>
</blockquote>
<h2 id="为什么先执行命令，再把数据写入日志呢？"><a href="#为什么先执行命令，再把数据写入日志呢？" class="headerlink" title="为什么先执行命令，再把数据写入日志呢？"></a>为什么先执行命令，再把数据写入日志呢？</h2><blockquote>
<p>好处<br>不会阻塞当前写操作命令的执行<br>避免额外的检查开销，先记的话AOF的命令是错的，恢复数据是会出现错误</p>
</blockquote>
<blockquote>
<p>坏处<br>数据可能丢失，写完服务器宕机<br>写AOF主线程阻塞之后的操作</p>
</blockquote>
<h2 id="Redis-写入-AOF-日志的过程"><a href="#Redis-写入-AOF-日志的过程" class="headerlink" title="Redis 写入 AOF 日志的过程"></a>Redis 写入 AOF 日志的过程</h2><blockquote>
<p>执行命令后将命令追加到AOF缓冲区，调用write()系统调用写入AOF文件，此时并未写入磁盘，只是拷贝到内核缓冲区page cache,等待内核写入磁盘</p>
</blockquote>
<h2 id="AOF-写回策略有几种？"><a href="#AOF-写回策略有几种？" class="headerlink" title="AOF 写回策略有几种？"></a>AOF 写回策略有几种？</h2><p><img src="https://img1.imgtp.com/2023/04/25/IRmorhyQ.png" alt="image" loading="lazy"></p>
<h2 id="AOF-日志过大，会触发什么机制？"><a href="#AOF-日志过大，会触发什么机制？" class="headerlink" title="AOF 日志过大，会触发什么机制？"></a>AOF 日志过大，会触发什么机制？</h2><blockquote>
<p>AOF重写机制<br>新的 AOF 文件覆盖现有的 AOF 文件<br>扫描子进程数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</p>
</blockquote>
<h2 id="重写-AOF-日志的过程是怎样的？"><a href="#重写-AOF-日志的过程是怎样的？" class="headerlink" title="重写 AOF 日志的过程是怎样的？"></a>重写 AOF 日志的过程是怎样的？</h2><blockquote>
<p>重写 AOF 过程是由后台子进程 bgrewriteaof 来完成。不会阻塞主进程，如果不发生写时复制则共享内存。如果发生了，拥有各自的数据副本，主进程追加写时复制的命令到AOF重写缓冲区，子进程重写完成后发信号给主进程，主进程执行信号处理函数，将AOF重写缓冲区中的命令追加到新AOF文件后覆盖旧文件</p>
</blockquote>
<h2 id="RDB-快照是如何实现的呢？"><a href="#RDB-快照是如何实现的呢？" class="headerlink" title="RDB 快照是如何实现的呢？"></a>RDB 快照是如何实现的呢？</h2><blockquote>
<p>AOF记录的是命令，而RDB记录的则是数据。在恢复数据的时候，直接加载数据自然比一步步执行命令要快的多得多</p>
</blockquote>
<h2 id="RDB-做快照时会阻塞线程吗？"><a href="#RDB-做快照时会阻塞线程吗？" class="headerlink" title="RDB 做快照时会阻塞线程吗？"></a>RDB 做快照时会阻塞线程吗？</h2><blockquote>
<p>save 在主线程中会阻塞主线程<br>bgsave 在子进程中不会阻塞主线程 可以通过配置来决定多长时间中进行多少次修改就进行一次RDB快照</p>
</blockquote>
<h2 id="RDB-在执行快照的时候，数据能修改吗？"><a href="#RDB-在执行快照的时候，数据能修改吗？" class="headerlink" title="RDB 在执行快照的时候，数据能修改吗？"></a>RDB 在执行快照的时候，数据能修改吗？</h2><blockquote>
<p>当然可以，通过写时复制结束</p>
</blockquote>
<blockquote>
<p>子进程写完RDB文件后就宕机，恢复数据是无法恢复最新的数据<br>最坏的情况下数据库中数据占据的内存大小会被加倍，注意内存大小</p>
</blockquote>
<h2 id="为什么会有混合持久化？"><a href="#为什么会有混合持久化？" class="headerlink" title="为什么会有混合持久化？"></a>为什么会有混合持久化？</h2><blockquote>
<p>RDB快照恢复数据快，但是丢失数据多<br>AOF日志恢复数据慢，但是丢失数据少<br>混合持久化恢复数据快，丢失数据少</p>
</blockquote>
<h2 id="混合持久化是如何实现的"><a href="#混合持久化是如何实现的" class="headerlink" title="混合持久化是如何实现的"></a>混合持久化是如何实现的</h2><blockquote>
<p>主线程不修改数据就往AOF文件中写入RDB数据<br>修改数据只会就写入AOF数据，AOF数据缓冲区，信号量之类的</p>
</blockquote>
<h2 id="混合持久化优点"><a href="#混合持久化优点" class="headerlink" title="混合持久化优点"></a>混合持久化优点</h2><h2 id="混合持久化缺点"><a href="#混合持久化缺点" class="headerlink" title="混合持久化缺点"></a>混合持久化缺点</h2><blockquote>
<p>可读性变差，AOF文件中写入RDB内容<br>兼容性变差，不可以在redis4.0之前使用</p>
</blockquote>
<h2 id="实现服务高可用-主从复制"><a href="#实现服务高可用-主从复制" class="headerlink" title="实现服务高可用-主从复制"></a>实现服务高可用-主从复制</h2><blockquote>
<p>多个服务器同步存储数据。主服务器可读写，从服务器只可读。主服务器同步从服务器，返回数据给客户端主服务不会等待从服务器确定同步，所以不可避免的出现数据不一致。</p>
</blockquote>
<h2 id="第一次同步数据和确定主从服务器"><a href="#第一次同步数据和确定主从服务器" class="headerlink" title="第一次同步数据和确定主从服务器"></a>第一次同步数据和确定主从服务器</h2><blockquote>
<p>建立链接、协商同步</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;主服务器 的 IP 地址&gt; &lt;主服务器的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从服务器执行以上命令<br>发送 psync 命令，包括主服务器的runID(不知道所以是？)，复制进度offset(-1)<br>主服务器回应FULLRESYNC(全量复制)，主服务器的 runID 和主服务器目前的复制进度 offset</p>
</blockquote>
<blockquote>
<p>主服务器同步数据给从服务器<br>生成一个RDB文件发给从服务器</p>
</blockquote>
<blockquote>
<p>主服务器发送新写操作命令给从服务器<br>replication buffer 缓冲区里<br>生成RDB<br>发送RDB<br>从服务器加载RDB(从服务器加载完后会恢复一个确认消息)</p>
</blockquote>
<h2 id="主从服务器在完成第一次同步后的数据一致性基于命令的TCP长连接"><a href="#主从服务器在完成第一次同步后的数据一致性基于命令的TCP长连接" class="headerlink" title="主从服务器在完成第一次同步后的数据一致性基于命令的TCP长连接"></a>主从服务器在完成第一次同步后的数据一致性基于命令的TCP长连接</h2><h2 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h2><blockquote>
<p>所有从服务器全部由主服务器管理不合理<br>将从服务器设置为经理服务器</p>
</blockquote>
<h2 id="网络断开增量复制的三个步骤"><a href="#网络断开增量复制的三个步骤" class="headerlink" title="网络断开增量复制的三个步骤"></a>网络断开增量复制的三个步骤</h2><blockquote>
<p>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1；<br>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；<br>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</p>
</blockquote>
<h2 id="主服务器怎么知道要将哪些增量数据发送给从服务器呢？"><a href="#主服务器怎么知道要将哪些增量数据发送给从服务器呢？" class="headerlink" title="主服务器怎么知道要将哪些增量数据发送给从服务器呢？"></a>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</h2><blockquote>
<p>repl_backlog_buffer,1M大小，环形缓冲区。<br>对比写进度和读进度，没覆盖就增量，覆盖了就全量，所以最好大一点，重连平均时间*单位时间写命令</p>
</blockquote>
<h2 id="Redis主从节点时长连接还是短连接？"><a href="#Redis主从节点时长连接还是短连接？" class="headerlink" title="Redis主从节点时长连接还是短连接？"></a>Redis主从节点时长连接还是短连接？</h2><h2 id="怎么判断-Redis-某个节点是否正常工作？"><a href="#怎么判断-Redis-某个节点是否正常工作？" class="headerlink" title="怎么判断 Redis 某个节点是否正常工作？"></a>怎么判断 Redis 某个节点是否正常工作？</h2><blockquote>
<p>心跳机制，ping一ping,一半以上ping不通就断开</p>
</blockquote>
<blockquote>
<p>主服务器10s ping，判断从节点状态<br>Redis 从节点每隔 1 秒,给主节点上报自身当前的复制偏移量，可以检测网络状态以及防止数据丢失</p>
</blockquote>
<h2 id="主从复制架构中，过期key如何处理？"><a href="#主从复制架构中，过期key如何处理？" class="headerlink" title="主从复制架构中，过期key如何处理？"></a>主从复制架构中，过期key如何处理？</h2><blockquote>
<p>主节点模拟一个del命令</p>
</blockquote>
<h2 id="为什么不用unlink"><a href="#为什么不用unlink" class="headerlink" title="为什么不用unlink"></a>为什么不用unlink</h2><blockquote>
<p>不可以批量删除key<br>异步删除不会马上释放内存空间，可能会导致二次同步。早起的redis4.0之前，待删除的keyAOF日志会记录，恢复数据后二次同步，之后就无所谓了</p>
</blockquote>
<h2 id="Redis-主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点"><a href="#Redis-主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点" class="headerlink" title="Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点"></a>Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点</h2><h2 id="主从复制中两个-Buffer-replication-buffer-、repl-backlog-buffer-有什么区别？"><a href="#主从复制中两个-Buffer-replication-buffer-、repl-backlog-buffer-有什么区别？" class="headerlink" title="主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？"></a>主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？</h2><blockquote>
<p>前者增量复制出现，后者增量复制和全量复制阶段都会出现。</p>
</blockquote>
<blockquote>
<p>前者满了或者说覆盖了，增量复制变全量复制。后者满了，断开连接，清空缓存，充连后重新复制</p>
</blockquote>
<h2 id="如何如何应对主从数据不一致？"><a href="#如何如何应对主从数据不一致？" class="headerlink" title="如何如何应对主从数据不一致？"></a>如何如何应对主从数据不一致？</h2><blockquote>
<p>主从数据不一致几乎无法避免</p>
</blockquote>
<blockquote>
<p>网络条件尽量好，主从服务器离的尽量近一些</p>
</blockquote>
<blockquote>
<p>监控主从服务器复制进度，差得太多就不让访问从节点</p>
</blockquote>
<h2 id="主从切换如何减少数据丢失？"><a href="#主从切换如何减少数据丢失？" class="headerlink" title="主从切换如何减少数据丢失？"></a>主从切换如何减少数据丢失？</h2><blockquote>
<p>无法杜绝，只能尽量减少</p>
</blockquote>
<blockquote>
<p>异步复制的时候储存在内存缓冲区中的写命令因为主服务器宕机丢失<br>防止主节点超过从节点命令太多，差得太多就不让访问主节点</p>
</blockquote>
<blockquote>
<p>集群产生脑裂数据丢失<br>因为网络，主节点和客户端连接良好，和从节点断开连接，接受写命令，哨兵选出新主节点，后来网络又好了，产生脑裂，第一次同步全量复制。<br>从节点断开太多或者网络延迟太大就直接返回错误给客户端，不让写</p>
</blockquote>
<h2 id="主从如何做到故障自动切换？"><a href="#主从如何做到故障自动切换？" class="headerlink" title="主从如何做到故障自动切换？"></a>主从如何做到故障自动切换？</h2><blockquote>
<p>哨兵机制</p>
</blockquote>
<h2 id="哨兵机制如何判断主节点真的故障了？"><a href="#哨兵机制如何判断主节点真的故障了？" class="headerlink" title="哨兵机制如何判断主节点真的故障了？"></a>哨兵机制如何判断主节点真的故障了？</h2><blockquote>
<p>ping一下，规定时间内不应答，判断主节点主观下线</p>
</blockquote>
<blockquote>
<p>考虑主节点繁忙和网络拥塞<br>哨兵集群  达到 quorum值一般大于一半加1 客观下线</p>
</blockquote>
<h2 id="由哪个哨兵进行主从故障转移？"><a href="#由哪个哨兵进行主从故障转移？" class="headerlink" title="由哪个哨兵进行主从故障转移？"></a>由哪个哨兵进行主从故障转移？</h2><blockquote>
<p>谁主观下线谁候选者，哨兵集群投票，谁超过一半且达到quorem谁进行转移</p>
</blockquote>
<h2 id="主从故障转移的过程是怎样的？"><a href="#主从故障转移的过程是怎样的？" class="headerlink" title="主从故障转移的过程是怎样的？"></a>主从故障转移的过程是怎样的？</h2><blockquote>
<p>选新主节点<br>首先排除已下线的和网络状态不好的，选优先级高的，选复制进度最高的，选id最小的<br>SLAVEOF no one</p>
</blockquote>
<blockquote>
<p>将从节点指向新主节点<br>SLAVEOF &lt;新主节点ip&gt; &lt;新主节点端口&gt;</p>
</blockquote>
<blockquote>
<p>通知客户的主节点已更换<br>发布者&#x2F;订阅者机制<br>从切换完成后，哨兵就会向 +switch-master 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了。</p>
</blockquote>
<blockquote>
<p>监控旧主节点，网络恢复时,变为从节点</p>
</blockquote>
<h2 id="主从复制和切片集群"><a href="#主从复制和切片集群" class="headerlink" title="主从复制和切片集群"></a>主从复制和切片集群</h2><blockquote>
<p>主从复制是数据复制，用来解决数据并发量大所带来的压力，而切片集群是数据切片，是用来解决单个实例存储大数据量的局限性，一主多从是用RDB来实现的，而切片集群是用哈希槽来实现的。</p>
</blockquote>
<h2 id="请求路由问题"><a href="#请求路由问题" class="headerlink" title="请求路由问题"></a>请求路由问题</h2><blockquote>
<p>多节点共享且客户端自己缓存一份<br>key 算出一个值 %16384 对应的哈希槽 对应节点</p>
</blockquote>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><blockquote>
<p>删除新增节点，重新分配hash槽</p>
</blockquote>
<blockquote>
<p>分配好了客户端访问，找不到hash槽，节点更新客户端缓存</p>
</blockquote>
<blockquote>
<p>hash槽数据量太大，还没分配好，指定节点，不更新缓存</p>
</blockquote>
<h2 id="过期删除策略之惰性删除策略"><a href="#过期删除策略之惰性删除策略" class="headerlink" title="过期删除策略之惰性删除策略"></a>过期删除策略之惰性删除策略</h2><blockquote>
<p>不主动删除key,每次从数据库中访问时过期则删除</p>
</blockquote>
<blockquote>
<p>优点：对cpu友好<br>缺点：对内存不友好</p>
</blockquote>
<h2 id="过期删除策略之定期删除策略"><a href="#过期删除策略之定期删除策略" class="headerlink" title="过期删除策略之定期删除策略"></a>过期删除策略之定期删除策略</h2><blockquote>
<p>每次从过期字典中抽取20个key,删除过期key,如果过期key超过1&#x2F;4，则再来一次。为了防止出现循环过度的情况，默认不超过25ms.</p>
</blockquote>
<blockquote>
<p>通过限制循环的时间和频率对cpu友好，又可以删除一部分的过期key，对内存友好</p>
</blockquote>
<blockquote>
<p>因为随机无法做到对时间和频率的掌控，多了对cpu不友好。少了和惰性删除一样</p>
</blockquote>
<h2 id="过期删除策略之定时删除策略"><a href="#过期删除策略之定时删除策略" class="headerlink" title="过期删除策略之定时删除策略"></a>过期删除策略之定时删除策略</h2><blockquote>
<p>创建一个定时事件，到时间后，自动删除</p>
</blockquote>
<blockquote>
<p>一到时间就删除，对内存最友好<br>再cpu繁忙时却去处理不相关的key,对cpu不友好</p>
</blockquote>
<h2 id="如何设置过期时间？"><a href="#如何设置过期时间？" class="headerlink" title="如何设置过期时间？"></a>如何设置过期时间？</h2><pre><code>expire &lt;key&gt; &lt;n&gt;
pexpire &lt;key&gt; &lt;n&gt;
TTL &lt;key&gt;
PERSIST &lt;key&gt;
</code></pre>
<h2 id="Redis-持久化时，对过期键会如何处理的？"><a href="#Redis-持久化时，对过期键会如何处理的？" class="headerlink" title="Redis 持久化时，对过期键会如何处理的？"></a>Redis 持久化时，对过期键会如何处理的？</h2><blockquote>
<p>对于RDB文件<br>生成过程中不受影响<br>加载过程中，主服务器不接受过期key,从服务器都接受，但其实无所谓，反正全量复制</p>
</blockquote>
<blockquote>
<p>对于AOF文件<br>写入时会写入过期键，确认过期后项AOF文件追加AOF命令<br>重写是过期键命令不会保存到重写的AOF文件</p>
</blockquote>
<h2 id="Redis-主从模式中，对过期键会如何处理？"><a href="#Redis-主从模式中，对过期键会如何处理？" class="headerlink" title="Redis 主从模式中，对过期键会如何处理？"></a>Redis 主从模式中，对过期键会如何处理？</h2><blockquote>
<p>主服务器在上面</p>
</blockquote>
<blockquote>
<p>从服务器不管，等待主服务器的命令传输</p>
</blockquote>
<h2 id="Redis-内存满了，会发生什么？"><a href="#Redis-内存满了，会发生什么？" class="headerlink" title="Redis 内存满了，会发生什么？"></a>Redis 内存满了，会发生什么？</h2><blockquote>
<p>到达某个阈值后就会触发内存淘汰策略</p>
</blockquote>
<h2 id="八种两类"><a href="#八种两类" class="headerlink" title="八种两类"></a>八种两类</h2><blockquote>
<p>不进行数据淘汰的策略<br>noeviction:不淘汰，不提供服务，返回错误</p>
</blockquote>
<blockquote>
<p>进行数据淘汰的策略</p>
</blockquote>
<blockquote>
<p>在设置了过期时间的数据中进行淘汰<br>volatile-random：随机淘汰设置了过期时间的任意键值；<br>volatile-ttl：优先淘汰更早过期的键值。<br>volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；<br>volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</p>
</blockquote>
<blockquote>
<p>在所有数据范围内进行淘汰：<br>allkeys-random：随机淘汰任意键值;<br>allkeys-lru：淘汰整个键值中最久未使用的键值；<br>allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</p>
</blockquote>
<h2 id="什么是-LRU-算法？"><a href="#什么是-LRU-算法？" class="headerlink" title="什么是 LRU 算法？"></a>什么是 LRU 算法？</h2><blockquote>
<p>最久未使用</p>
</blockquote>
<h2 id="Redis-是如何实现-LRU-算法的？"><a href="#Redis-是如何实现-LRU-算法的？" class="headerlink" title="Redis 是如何实现 LRU 算法的？"></a>Redis 是如何实现 LRU 算法的？</h2><blockquote>
<p>在Redis结构体中创建一个记录最新访问时间的字段<br>24位的lru字段 时间戳<br>优：不用创建大链表节省内存。不用移动链表，提高性能</p>
</blockquote>
<blockquote>
<p>缺:缓存污染</p>
</blockquote>
<h2 id="什么是-LFU-算法？"><a href="#什么是-LFU-算法？" class="headerlink" title="什么是 LFU 算法？"></a>什么是 LFU 算法？</h2><blockquote>
<p>最近最不常用</p>
</blockquote>
<h2 id="Redis-是如何实现-LFU-算法的？"><a href="#Redis-是如何实现-LFU-算法的？" class="headerlink" title="Redis 是如何实现 LFU 算法的？"></a>Redis 是如何实现 LFU 算法的？</h2><blockquote>
<p>24位的lru字段 高16位时间戳 低八位访问频次</p>
</blockquote>
<h2 id="如何避免缓存雪崩？-redis作为数据库缓存"><a href="#如何避免缓存雪崩？-redis作为数据库缓存" class="headerlink" title="如何避免缓存雪崩？(redis作为数据库缓存)"></a>如何避免缓存雪崩？(redis作为数据库缓存)</h2><blockquote>
<p>当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题</p>
</blockquote>
<blockquote>
<p>大量数据同时过期失效</p>
</blockquote>
<blockquote>
<p>均匀设置过期时间:失效时间加上一个随机值<br>互斥锁：同一时间只有一个请求构建缓存，要么 等待释放锁，要么返回空值或者默认值。记得设置超时时间<br>双 key 策略:主key过期，备key不过期<br>后台更新缓存：缓存永久有效，但是当内存紧张缓存依旧会被淘汰。业务线程发现缓存不存在就通知后台线程更新缓存。业务上线之前提前缓存数据进行缓存预热。</p>
</blockquote>
<blockquote>
<p>Redis 故障宕机</p>
</blockquote>
<blockquote>
<p>服务熔断和请求限流机制(已经发生了)<br>不查缓存，只查数据库<br>防止数据库崩溃，只响应部分请求</p>
</blockquote>
<blockquote>
<p>缓存集群(避免发生)</p>
</blockquote>
<h2 id="如何避免缓存击穿？"><a href="#如何避免缓存击穿？" class="headerlink" title="如何避免缓存击穿？"></a>如何避免缓存击穿？</h2><blockquote>
<p>缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题.</p>
</blockquote>
<blockquote>
<p>缓存击穿是缓存雪崩的一个子集</p>
</blockquote>
<blockquote>
<p>均匀设置过期时间:失效时间加上一个随机值<br>互斥锁：同一时间只有一个请求构建缓存，要么 等待释放锁，要么返回空值或者默认值。记得设置超时时间<br>双 key 策略:主key过期，备key不过期<br>后台更新缓存：缓存永久有效，但是当内存紧张缓存依旧会被淘汰。业务线程发现缓存不存在就通知后台线程更新缓存。业务上线之前提前缓存数据进行缓存预热。</p>
</blockquote>
<h2 id="如何避免缓存穿透？"><a href="#如何避免缓存穿透？" class="headerlink" title="如何避免缓存穿透？"></a>如何避免缓存穿透？</h2><blockquote>
<p>缓存中不存在，数据库中也不存在</p>
</blockquote>
<blockquote>
<p>业务操作失误，删除数据<br>黑客攻击 故意访问不存在数据</p>
</blockquote>
<blockquote>
<p>非法请求的限制:不合规，含有非法制，请求字段不存在返回错误<br>设置空值或者默认值：二次访问缓存返回，不访问数据库<br>用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在.位数组加上对key的多次hash,能查到不一定在，但是查不到一定不在</p>
</blockquote>
<p><img src="https://img1.imgtp.com/2023/04/25/IRmorhyQ.png" alt="image" loading="lazy"></p>
<h2 id="如何设计一个缓存策略，可以动态缓存热点数据呢？"><a href="#如何设计一个缓存策略，可以动态缓存热点数据呢？" class="headerlink" title="如何设计一个缓存策略，可以动态缓存热点数据呢？"></a>如何设计一个缓存策略，可以动态缓存热点数据呢？</h2><blockquote>
<p>选一部分数据作为热点数据。利用有序集合zadd和zrange。根据最新访问时间排序，定期淘汰最末端的数据，在从数据库中选一些数据加入。</p>
</blockquote>
<h2 id="Redis-和-MySQL-的缓存更新策略"><a href="#Redis-和-MySQL-的缓存更新策略" class="headerlink" title="Redis 和 MySQL 的缓存更新策略"></a>Redis 和 MySQL 的缓存更新策略</h2><blockquote>
<p>旁路缓存<br>写策略和读策略<br>写策略必须先更新数据库再删除缓存，否则在读写并发的环境下会发生缓存与数据库数据不一致。逻辑上其实先删除缓存也会不一致，但是几乎不会发生。缓存的更新比数据库的更新快的多得多。另外可以给缓存加一个过期时间兜底</p>
</blockquote>
<blockquote>
<p>适合读多写少，不然经常缓存不命中</p>
</blockquote>
<h2 id="Read-Write-Through（读穿-写穿）策略"><a href="#Read-Write-Through（读穿-写穿）策略" class="headerlink" title="Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略"></a>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</h2><blockquote>
<p>应用程序之后缓存打交道，只是在写不命中时直接修改数据库</p>
</blockquote>
<h2 id="Write-Back（写回）策略"><a href="#Write-Back（写回）策略" class="headerlink" title="Write Back（写回）策略"></a>Write Back（写回）策略</h2><blockquote>
<p>脏数据，异步更新</p>
</blockquote>
<h2 id="Redis-如何实现延迟队列？"><a href="#Redis-如何实现延迟队列？" class="headerlink" title="Redis 如何实现延迟队列？"></a>Redis 如何实现延迟队列？</h2><blockquote>
<p>有序队列，zadd添加，zrangebysocre轮循查询，比对socre和当前时间</p>
</blockquote>
<h2 id="什么是-Redis-大-key？"><a href="#什么是-Redis-大-key？" class="headerlink" title="什么是 Redis 大 key？"></a>什么是 Redis 大 key？</h2><blockquote>
<p>value很大<br>String 类型的值大于 10 KB；<br>Hash、List、Set、ZSet 类型的元素的个数超过 5000个</p>
</blockquote>
<h2 id="大-key-会造成什么问题？"><a href="#大-key-会造成什么问题？" class="headerlink" title="大 key 会造成什么问题？"></a>大 key 会造成什么问题？</h2><blockquote>
<p>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。<br>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。<br>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。<br>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</p>
</blockquote>
<h2 id="如何找到大-key-？"><a href="#如何找到大-key-？" class="headerlink" title="如何找到大 key ？"></a>如何找到大 key ？</h2><blockquote>
<p>RdbTools ,解析RDB文件，10kb,输出到一个摆个中</p>
</blockquote>
<h2 id="如何删除大-key？"><a href="#如何删除大-key？" class="headerlink" title="如何删除大 key？"></a>如何删除大 key？</h2><blockquote>
<p>unlink异步</p>
</blockquote>
<h2 id="Redis-管道有什么用？"><a href="#Redis-管道有什么用？" class="headerlink" title="Redis 管道有什么用？"></a>Redis 管道有什么用？</h2><blockquote>
<p>一次性发送多个命令，等待结果</p>
</blockquote>
<h2 id="Redis-事务支持回滚吗？"><a href="#Redis-事务支持回滚吗？" class="headerlink" title="Redis 事务支持回滚吗？"></a>Redis 事务支持回滚吗？</h2><blockquote>
<p>不支持事务运行时错误的事务回滚,即使错误依旧入队，执行正确的事务命令，不像mysql的事务是原子性的，要么成功，要么失败</p>
</blockquote>
<h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/112691126">https://blog.csdn.net/a745233700/article/details/112691126</a></p>
</blockquote>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>bbkkp</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://bbkkp.github.io/2024/08/31/redis%20stereotyped%20writing.html/" title="redis八股文">https://bbkkp.github.io/2024/08/31/redis%20stereotyped%20writing.html/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2024/08/31/mysql%20stereotyped%20writing.html/" rel="prev" title="mysql八股文"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">mysql八股文</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2024/08/31/design%20mode%20stereotyped%20writing.html/" rel="next" title="设计模式八股文"><span class="post-nav-text">设计模式八股文</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2024 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> bbkkp</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div><div class="live-time"><span>感谢陪伴</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2024-08-30T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div><div class="footer-custom-text"><a href="yourLink" rel="noopener" target="_blank">学就完了</a></div><div class="footer-support"><span>本站由</span><a class="footer-support-logo" href="https://www.rainyun.com/YeMeng_" target="blank" title="雨云"><img height="30" src="https://cn-sy1.rains3.com/yemenghexo/rainyunlogo.png" alt="雨云"></a><span>提供 对象存储 服务</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>