<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="bbkkp"><meta name="copyright" content="bbkkp"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>C++八股文 | bbkkpの折腾日记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"bbkkp.github.io","root":"/","title":"踏着梦走过时光","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="在main执行之前和之后执行的代码可能是什么？ 之前   全员对象的构造 初始化.data,.bss段的内容 设置栈指针 attribute((constructor)) 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数   之后   全局对象析构 atexit注册一个函数指针 attribute((destructor))  结构体内存对齐问题？ 未特殊说明">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股文">
<meta property="og:url" content="https://bbkkp.github.io/2024/08/31/C++%20eight-part%20text.html/index.html">
<meta property="og:site_name" content="bbkkpの折腾日记">
<meta property="og:description" content="在main执行之前和之后执行的代码可能是什么？ 之前   全员对象的构造 初始化.data,.bss段的内容 设置栈指针 attribute((constructor)) 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数   之后   全局对象析构 atexit注册一个函数指针 attribute((destructor))  结构体内存对齐问题？ 未特殊说明">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.imgtp.com/2023/04/30/RXxU9rXx.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/04/30/UWAQzJ3C.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/lO9kwkQI.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/12/g1BA9cZE.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/06/zDOOv5ZT.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/06/fj10k6Po.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/06/UmVYagNN.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/06/VU5t5jWv.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/j7RXUEKe.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/TTFdUe3k.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/KHmZm14C.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/1UaGARXF.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/H9yeaUWQ.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/jwXna1wn.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/W2luJC77.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/qemv9jfo.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/SPnniiBI.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/2mFrr1aC.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/j9ZrSL3r.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/AdNzw6LJ.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/VLNGG8tr.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/XZrQaKJD.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/GQkExGR7.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/5HQhXOK7.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/07/bJokf2kP.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/12/dJpKcEqA.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/12/febTSFKN.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/05/12/vgefrAem.png">
<meta property="article:published_time" content="2024-08-31T14:01:24.000Z">
<meta property="article:modified_time" content="2024-08-31T14:02:02.201Z">
<meta property="article:author" content="bbkkp">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.imgtp.com/2023/04/30/RXxU9rXx.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="bbkkp"><img width="96" loading="lazy" src="/images/head.jpg" alt="bbkkp"><span class="site-author-status" title="四季花开">☺️</span></a><div class="site-author-name"><a href="/about/">bbkkp</a></div><span class="site-name">bbkkpの折腾日记</span><sub class="site-subtitle">一个人的世界</sub><div class="site-description">踏着梦走过时光</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">55</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">13</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">39</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/bbkkp" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="2094921157@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" target="_blank" rel="noopener" href="https://github.com/bbkkp" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">结构体内存对齐问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete-%E4%B8%8E-malloc-free%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">6.</span> <span class="toc-text">new &#x2F; delete 与 malloc &#x2F; free的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">7.</span> <span class="toc-text">new和delete是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">被free回收的内存是立即返还给操作系统吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strlen%E5%92%8Csizeof%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">strlen和sizeof区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="toc-number">10.</span> <span class="toc-text">一个指针占多少字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">C++中struct和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">define宏定义和const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cinline%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text"> define宏定义和inline的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%ADconst%E5%92%8Cstatic%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">C++中const和static的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%BA%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">数组名和指针（这里为指向数组首元素的指针）区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%92%8Coverride%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">16.</span> <span class="toc-text">final和override关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">定义和初始化和赋值的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">18.</span> <span class="toc-text">拷贝初始化和直接初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern%E2%80%9DC%E2%80%9D%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">19.</span> <span class="toc-text">extern”C”的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">20.</span> <span class="toc-text">野指针和悬空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%87%8D%E5%86%99%EF%BC%8C%E9%9A%90%E8%97%8F"><span class="toc-number">21.</span> <span class="toc-text">重载，重写，隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">C++有哪几种的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">浅拷贝和深拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">如何用代码判断大小端存储？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E3%80%81mutable%E5%92%8Cexplicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">25.</span> <span class="toc-text">volatile、mutable和explicit关键字的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">26.</span> <span class="toc-text">什么情况下会调用拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84new"><span class="toc-number">27.</span> <span class="toc-text">C++中有几种类型的new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">28.</span> <span class="toc-text">C++的异常处理的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">29.</span> <span class="toc-text">顶层const和底层const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">30.</span> <span class="toc-text">静态变量什么时候初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete-p%E3%80%81delete-p"><span class="toc-number">31.</span> <span class="toc-text">delete p、delete [] p</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%9A%84"><span class="toc-number">32.</span> <span class="toc-text">delete是如何知道释放内存的大小的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc%E3%80%81realloc%E3%80%81calloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">33.</span> <span class="toc-text">malloc、realloc、calloc的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">类成员初始化方式？为什么用成员初始化列表会快一些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E7%94%A8%E5%88%B0%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">有哪些情况必须用到成员列表初始化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E6%96%B0%E5%A2%9E%E4%BA%86string%EF%BC%8C%E5%AE%83%E4%B8%8EC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D"><span class="toc-number">37.</span> <span class="toc-text">什么是内存泄露，如何检测与避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">38.</span> <span class="toc-text">基类析构函数为什么要定义为虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">39.</span> <span class="toc-text">对象复用的了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">40.</span> <span class="toc-text">面向对象三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">41.</span> <span class="toc-text">C++的四种强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99C-%E4%BB%A3%E7%A0%81%E6%97%B6%E6%9C%89%E4%B8%80%E7%B1%BB%E9%94%99%E8%AF%AF%E6%98%AF-coredump-%EF%BC%8C%E5%BE%88%E5%B8%B8%E8%A7%81%EF%BC%8C%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">43.</span> <span class="toc-text">说说移动构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%B0%86%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">44.</span> <span class="toc-text">C++中将临时变量作为返回值时的处理过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%BB%93%E6%9E%84%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E8%8A%82%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">45.</span> <span class="toc-text">如何获得结构成员相对于结构开头的字节偏移量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">46.</span> <span class="toc-text">静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%BD%A2%E5%8F%82"><span class="toc-number">47.</span> <span class="toc-text">虚函数与默认形参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">引用是否能实现动态绑定，为什么可以实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">全局变量和局部变量有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">指针加减计算要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">怎样判断两个浮点数是否相等？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%83%B3%E5%B0%86%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BD%9C%E5%9F%BA%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E8%80%8C%E9%9D%9E%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">如果想将某个类用作基类，为什么该类必须定义而非声明？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">继承机制中对象之间如何转换？指针和引用之间如何转换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%88%96%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">55.</span> <span class="toc-text">C++如何实现类对象只能动态分配或只能静态分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E9%81%93C-%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88%E5%90%97%EF%BC%9F%E5%AE%83%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%90%97%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">知道C++中的组合吗？它与继承相比有什么优缺点吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B9%88"><span class="toc-number">57.</span> <span class="toc-text">为什么要有函数指针,直接调用不可以么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">58.</span> <span class="toc-text">结构体变量比较是否相等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93printf%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">你知道printf函数的实现原理是什么吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cout%E5%92%8Cprintf%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">cout和printf有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-number">61.</span> <span class="toc-text">C++中类成员的访问权限和继承权限问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">63.</span> <span class="toc-text">定义和声明的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">64.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">65.</span> <span class="toc-text">重载&lt;&lt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%89%8D%E7%BD%AE-%EF%BC%8C%E5%90%8E%E7%BD%AE"><span class="toc-number">66.</span> <span class="toc-text">重载前置++，后置++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-1"><span class="toc-number">67.</span> <span class="toc-text">重载&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9F%E4%BD%A0%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">68.</span> <span class="toc-text">如何在不使用额外空间的情况下，交换两个数？你有几种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">隐式转换，如何消除隐式转换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%EF%BC%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">70.</span> <span class="toc-text">条件编译，头文件重复包含的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8Cint-main-int-argc-char-argv-%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">如果有一个空类，它会默认添加哪些函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E3%80%81char-%E3%80%81const-char"><span class="toc-number">73.</span> <span class="toc-text">string、char 、const char</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E4%BB%85%E5%8D%95%E4%B8%AA%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="toc-number">74.</span> <span class="toc-text">如何设计一个计算仅单个子类的对象个数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">75.</span> <span class="toc-text">如何阻止一个类被实例化？有哪些方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">76.</span> <span class="toc-text">如何禁止程序自动生成拷贝构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93Debug%E5%92%8CRelease%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">你知道Debug和Release的区别是什么吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9C%89%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E8%80%83%E7%A9%B6%E4%B9%8B%E5%A4%84%E5%90%97%EF%BC%9F"><span class="toc-number">78.</span> <span class="toc-text">main函数的返回值有什么值得考究之处吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E8%BF%99%E7%82%B9%E8%B7%9FJava%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E3%80%82"><span class="toc-number">79.</span> <span class="toc-text">为什么C++没有垃圾回收机制？这点跟Java不太一样。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8Cmemset-this-0-sizeof-this-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">80.</span> <span class="toc-text">成员函数里memset(this,0,sizeof(*this))会发生什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">81.</span> <span class="toc-text">C++从代码到可执行程序经历了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">82.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">83.</span> <span class="toc-text">类的对象存储空间？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A9%BA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF1"><span class="toc-number">84.</span> <span class="toc-text">为什么空类的大小是1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8EC-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">85.</span> <span class="toc-text">简要说明C++的内存分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">86.</span> <span class="toc-text">内存池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-number">87.</span> <span class="toc-text">C++中类的数据成员和成员函数内存分布情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">88.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">89.</span> <span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">90.</span> <span class="toc-text">在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">91.</span> <span class="toc-text">如果在类的析构函数中调用delete this，会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-%E6%8E%A8%E5%AF%BC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%9C%89%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">92.</span> <span class="toc-text">auto 推导类型，必须有初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype%E8%BF%94%E5%9B%9E%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">93.</span> <span class="toc-text">decltype返回操作数的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype-auto-c-14"><span class="toc-number">94.</span> <span class="toc-text">decltype(auto) c++14</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%ADNULL%E5%92%8Cnullptr%E5%8C%BA%E5%88%AB"><span class="toc-number">95.</span> <span class="toc-text">C++中NULL和nullptr区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">96.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trivial-destructor"><span class="toc-number">97.</span> <span class="toc-text">trivial destructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAII"><span class="toc-number">98.</span> <span class="toc-text">RAII</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAII%E7%9A%84%E4%BB%A3%E8%A1%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">99.</span> <span class="toc-text">RAII的代表智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E7%B1%BB"><span class="toc-number">100.</span> <span class="toc-text">智能指针分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">101.</span> <span class="toc-text">强引用和弱引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">102.</span> <span class="toc-text">智能指针和普通指针的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E6%B2%A1%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">103.</span> <span class="toc-text">智能指针有没有内存泄露的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-shared-ptr-%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">104.</span> <span class="toc-text">weak_ptr 如何解决 shared_ptr 的循环引用问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">105.</span> <span class="toc-text">智能指针是否线程安全?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https-blog-csdn-net-haimianjie2012-article-details-104818736"><span class="toc-number">106.</span> <span class="toc-text">https:&#x2F;&#x2F;blog.csdn.net&#x2F;haimianjie2012&#x2F;article&#x2F;details&#x2F;104818736</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%8D%95%E6%8D%89%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">107.</span> <span class="toc-text">C++11 lambda表达式的捕捉方式有哪几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9A-it%E3%80%81it-%E5%93%AA%E4%B8%AA%E5%A5%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">108.</span> <span class="toc-text">迭代器：++it、it++哪个好，为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">109.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">110.</span> <span class="toc-text">vector与list的区别与应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E6%89%A9%E5%AE%B9"><span class="toc-number">111.</span> <span class="toc-text">vector扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4"><span class="toc-number">112.</span> <span class="toc-text">Vector如何释放空间?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">113.</span> <span class="toc-text">容器内部删除一个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B1%9E%E6%80%A7"><span class="toc-number">114.</span> <span class="toc-text">STL迭代器的五种属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E4%B8%AD-%E4%B8%8Efind%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">115.</span> <span class="toc-text">map中[]与find的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%EF%BC%88%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8%E5%8F%8A%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8%EF%BC%89"><span class="toc-number">116.</span> <span class="toc-text">STL空间配置器（一级配置器及二级配置器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%B8%AD%E7%9A%84allocator%E3%80%81deallocator"><span class="toc-number">117.</span> <span class="toc-text">STL中的allocator、deallocator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%B9%8Bhashtable"><span class="toc-number">118.</span> <span class="toc-text">STL之hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%B8%AD%E6%AF%8F%E7%A7%8D%E5%AE%B9%E5%99%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">119.</span> <span class="toc-text">STL中每种容器对应的迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">120.</span> <span class="toc-text">说说迭代器失效的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%A4%9A%E6%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">121.</span> <span class="toc-text">C++的多态如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">122.</span> <span class="toc-text">构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88vptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4"><span class="toc-number">123.</span> <span class="toc-text">基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">124.</span> <span class="toc-text">模板函数和模板类的特例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">125.</span> <span class="toc-text">构造函数、析构函数、虚函数可否声明为内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">126.</span> <span class="toc-text">构造函数和析构函数可以调用虚函数吗，为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">127.</span> <span class="toc-text">构造函数、析构函数的内部执行顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">128.</span> <span class="toc-text">构造函数析构函数可否抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">129.</span> <span class="toc-text">构造函数的几种关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E8%99%9A%E8%A1%A8%E5%B8%83%E5%B1%80-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E8%99%9A%E5%87%BD%E6%95%B0-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="toc-number">130.</span> <span class="toc-text">虚函数单一继承虚表布局(成员变量+虚函数+虚函数覆盖)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%99%9A%E8%A1%A8%E5%B8%83%E5%B1%80-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E8%99%9A%E5%87%BD%E6%95%B0-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="toc-number">131.</span> <span class="toc-text">虚函数多继承虚表布局(成员变量+虚函数+虚函数覆盖)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%B7%B1%E5%BA%A6%E4%B8%BA2%E7%9A%84%E7%BB%A7%E6%89%BF-%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%90%8E%E5%86%8D%E5%8D%95%E7%BB%A7%E6%89%BF-%E8%99%9A%E8%A1%A8%E5%B8%83%E5%B1%80-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E8%99%9A%E5%87%BD%E6%95%B0-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="toc-number">132.</span> <span class="toc-text">虚函数深度为2的继承(多继承后再单继承)虚表布局(成员变量+虚函数+虚函数覆盖)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%A4%8D%E7%BB%A7%E6%89%BF%E8%99%9A%E8%A1%A8%E5%B8%83%E5%B1%80-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E8%99%9A%E5%87%BD%E6%95%B0-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="toc-number">133.</span> <span class="toc-text">虚函数重复继承虚表布局(成员变量+虚函数+虚函数覆盖)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%BA%E7%8E%B0%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%A4%9A%E4%B8%AA%E9%97%B4%E6%8E%A5%E7%88%B6%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-number">134.</span> <span class="toc-text"> 虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vftptr-%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E6%8C%87%E5%90%91%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-vbptr-%E8%99%9A%E5%9F%BA%E7%B1%BB%E6%8C%87%E9%92%88-%E6%8C%87%E5%90%91%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8"><span class="toc-number">135.</span> <span class="toc-text">vftptr 虚函数指针 指向虚函数表 vbptr 虚基类指针 指向虚基类表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%BB%A5%E5%8F%8A%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%85%A8%E9%87%8D%E8%BD%BD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%97%A0%E5%A4%A7%E5%B0%8F"><span class="toc-number">136.</span> <span class="toc-text">虚继承下的单一继承以及派生类全重载的虚函数指针无大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E6%97%A2%E6%9C%89%E8%99%9A%E7%BB%A7%E6%89%BF%E5%8F%88%E5%AD%98%E5%9C%A8%E4%B8%80%E8%88%AC%E7%BB%A7%E6%89%BF%E4%B8%AD%E4%B8%80%E8%88%AC%E7%BB%A7%E6%89%BF%E5%9C%A8%E5%89%8D"><span class="toc-number">137.</span> <span class="toc-text">虚继承下的多继承，既有虚继承又存在一般继承中一般继承在前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%85%A8%E9%83%A8%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">138.</span> <span class="toc-text">虚继承下的多继承全部虚继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%BB%E7%9F%B3%E5%9E%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-%E5%90%AB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E8%99%9A%E5%87%BD%E6%95%B0-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="toc-number">139.</span> <span class="toc-text">钻石型的虚拟多重继承(含成员变量+虚函数+虚函数覆盖)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11%E7%BA%BF%E7%A8%8B%E6%96%B9%E9%9D%A2%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">140.</span> <span class="toc-text">c++11线程方面的内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%BC%96%E8%BE%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">141.</span> <span class="toc-text">什么情况下编辑器自动生成默认的构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">142.</span> <span class="toc-text">那什么时候需要合成拷贝构造函数呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">143.</span> <span class="toc-text">抽象基类为什么不能创建对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC%EF%BC%9F"><span class="toc-number">144.</span> <span class="toc-text">为什么拷贝构造函数必须传引用不能传值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E8%83%BD%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E5%B8%B8%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">145.</span> <span class="toc-text">静态函数能定义为虚函数吗？常函数呢？说说你的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E6%8A%8A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="toc-number">146.</span> <span class="toc-text">哪些函数不能是虚函数？把你知道的都说一说</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">147.</span> <span class="toc-text">什么是纯虚函数，与虚函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">148.</span> <span class="toc-text"> 内存池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">149.</span> <span class="toc-text"> 连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">150.</span> <span class="toc-text">检测内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8D%B1%E5%AE%B3"><span class="toc-number">151.</span> <span class="toc-text">内存泄露危害</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="toc-number">152.</span> <span class="toc-text">异常机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">153.</span> <span class="toc-text">常见异常类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-number">154.</span> <span class="toc-text">priority queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">155.</span> <span class="toc-text">移动构造和拷贝构造的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">156.</span> <span class="toc-text">右值引用与左值引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%8F%B3%E5%80%BC%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">157.</span> <span class="toc-text">引入右值的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E7%9A%84std-function%E5%92%8Cstd-bind"><span class="toc-number">158.</span> <span class="toc-text">C++11的std::function和std::bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foeward%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">159.</span> <span class="toc-text">foeward完美转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E8%AF%AD%E8%A8%80%E7%BA%A7%E5%88%AB%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">160.</span> <span class="toc-text">c++语言级别的多线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">构造函数</span></a></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://bbkkp.github.io/2024/08/31/C++%20eight-part%20text.html/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="bbkkp"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="bbkkpの折腾日记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++八股文</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2024-08-31 22:01:24" itemprop="dateCreated datePublished" datetime="2024-08-31T22:01:24+08:00">2024-08-31</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">八股文</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/C/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">C++</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="在main执行之前和之后执行的代码可能是什么？"><a href="#在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="在main执行之前和之后执行的代码可能是什么？"></a>在main执行之前和之后执行的代码可能是什么？</h2><blockquote>
<p>之前</p>
</blockquote>
<ol>
<li>全员对象的构造</li>
<li>初始化.data,.bss段的内容</li>
<li>设置栈指针</li>
<li><strong>attribute</strong>((constructor))</li>
<li>将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数</li>
</ol>
<blockquote>
<p>之后</p>
</blockquote>
<ol>
<li>全局对象析构</li>
<li>atexit注册一个函数指针</li>
<li><strong>attribute</strong>((destructor))</li>
</ol>
<h2 id="结构体内存对齐问题？"><a href="#结构体内存对齐问题？" class="headerlink" title="结构体内存对齐问题？"></a>结构体内存对齐问题？</h2><blockquote>
<p>未特殊说明，第一个成员地址等同于结构体地址,对齐方式为最大字节成员。每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</p>
</blockquote>
<blockquote>
<p>alignof查看对齐方式<br>alignas指定对齐方式【不可以指定奇数，报错，不可以指定小于正常对齐方式的数，忽视】单字节对齐无效</p>
</blockquote>
<blockquote>
<p>单字节对齐<br>#pragma pack(push,1)<br>#pragma pack(pop)<br>配合位对齐</p>
</blockquote>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><blockquote>
<p>相同点<br>都是内存的概念，子啊汇编上都是一个地址</p>
</blockquote>
<blockquote>
<p>区别</p>
</blockquote>
<ol>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用使用时无需解引用（*），指针需要解引用；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li>
<li>引用不能为空，指针可以为空</li>
<li>“sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身（所指向的变量或对象的地址）的大小；</li>
</ol>
<h2 id="在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h2><p><img src="https://img1.imgtp.com/2023/04/30/RXxU9rXx.png" alt="image" loading="lazy"></p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p><img src="https://img1.imgtp.com/2023/04/30/UWAQzJ3C.png" alt="image" loading="lazy"></p>
<h2 id="new-delete-与-malloc-free的异同"><a href="#new-delete-与-malloc-free的异同" class="headerlink" title="new &#x2F; delete 与 malloc &#x2F; free的异同"></a>new &#x2F; delete 与 malloc &#x2F; free的异同</h2><blockquote>
<p>相同点<br>都可用于内存的动态申请和释放</p>
</blockquote>
<blockquote>
<p>不同点<br>前者是C++运算符，后者是C&#x2F;C++语言标准库函数<br>new自动计算要分配的空间大小，malloc需要手工计算<br>new是类型安全的，malloc不是。分配内存的类型和指定指针的类型是否匹配<br>是否还会构造，析构对象<br>返回void 指针必须强转，具体类型指针</p>
</blockquote>
<h2 id="new和delete是如何实现的"><a href="#new和delete是如何实现的" class="headerlink" title="new和delete是如何实现的"></a>new和delete是如何实现的</h2><blockquote>
<p>分配内存，构造函数构造对象，返回指针</p>
</blockquote>
<blockquote>
<p>析构函数析构对象，释放内存</p>
</blockquote>
<h2 id="被free回收的内存是立即返还给操作系统吗？"><a href="#被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="被free回收的内存是立即返还给操作系统吗？"></a>被free回收的内存是立即返还给操作系统吗？</h2><blockquote>
<p>不会</p>
</blockquote>
<h2 id="strlen和sizeof区别？"><a href="#strlen和sizeof区别？" class="headerlink" title="strlen和sizeof区别？"></a>strlen和sizeof区别？</h2><blockquote>
<p>任何数据类型，只能是字符串，末尾\0<br>编译期确定，不能得到动态分配存储空间大小</p>
</blockquote>
<h2 id="一个指针占多少字节"><a href="#一个指针占多少字节" class="headerlink" title="一个指针占多少字节"></a>一个指针占多少字节</h2><blockquote>
<p>编译环境</p>
</blockquote>
<h2 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h2><blockquote>
<p>默认访问权限</p>
</blockquote>
<h2 id="define宏定义和const的区别"><a href="#define宏定义和const的区别" class="headerlink" title="define宏定义和const的区别"></a>define宏定义和const的区别</h2><blockquote>
<p>编译阶段 define是在编译的预处理阶段起作用，而const是在编译的时候起作用</p>
</blockquote>
<blockquote>
<p>安全性<br>define只做替换，不做类型检查和计算;const编译器会做安全检查</p>
</blockquote>
<blockquote>
<p>内存占用<br>define只是替换，会用多个相同的备份。const只会有一个</p>
</blockquote>
<h2 id="x20-define宏定义和inline的区别"><a href="#x20-define宏定义和inline的区别" class="headerlink" title="&#x20;define宏定义和inline的区别"></a>&#x20;define宏定义和inline的区别</h2><blockquote>
<p>编译阶段 define是在编译的预处理阶段起作用，而inline是在编译的时候起作用</p>
<p>安全性 define只做替换，不做安全检查;inline编译器会做安全检查</p>
<p>函数调用 define只是替换，函数依旧调用。inline直接将函数体代码放进代码文件中，省去函数调用。</p>
<p>另外对于一个函数是否内联其实是由编译器决定，程序员只是建议，具体是否内联看情况。比如函数体过大，存在循环就不会内联，还有虚函数也不行</p>
<p>而且宏定义存在二义性，必须将参数括起来。inline就不必要</p>
</blockquote>
<h2 id="C-中const和static的作用"><a href="#C-中const和static的作用" class="headerlink" title="C++中const和static的作用"></a>C++中const和static的作用</h2><blockquote>
<p>static<br>不属于类的函数或者变量作用域是整个文件<br>属于类的变量归属于类，所有对象只有一份拷贝；函数没有this指针，只可以访问static成员变量。成员函数不可以是虚函数，虚指针需要通过this指针调用<br>static成员变量必须在类外进行初始化，先于对象。</p>
</blockquote>
<blockquote>
<p>const<br>只读变量<br>参数在函数中不会被修改<br>顶层const,底层const<br>类的const成员变量必须在类中的构造函数列表初始化<br>指定成员函数为const，不修改成员变量<br>返回值是const,不返回左值</p>
</blockquote>
<h2 id="数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="数组名和指针（这里为指向数组首元素的指针）区别？"></a>数组名和指针（这里为指向数组首元素的指针）区别？</h2><blockquote>
<p>都可以通过加一减一访问数组元素<br>但是数组名不支持自增自减的操作，而且当数组名作为形参是，会退化成一般指针，失去sizeof(数组名)得到数组大小的功能</p>
</blockquote>
<h2 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h2><blockquote>
<p>override<br>子类中的某个函数一定继承自父类</p>
</blockquote>
<blockquote>
<p>final<br>不希望某个类或者某个函数被继承</p>
</blockquote>
<h2 id="定义和初始化和赋值的区别"><a href="#定义和初始化和赋值的区别" class="headerlink" title="定义和初始化和赋值的区别"></a>定义和初始化和赋值的区别</h2><blockquote>
<p>简单数据类型没什么区别<br>复杂数据类型 直接初始化和拷贝初始化或者&#x3D;运算符重载</p>
</blockquote>
<h2 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h2><blockquote>
<p>1）什么是拷贝初始化（也称为复制初始化）：将一个已有的对象拷贝到正在创建的对象，如果需要的话还需要进行类型转换。拷贝初始化发生在下列情况：<br>使用赋值运算符定义变量<br>将对象作为实参传递给一个非引用类型的形参<br>将一个返回类型为非引用类型的函数返回一个对象<br>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>
</blockquote>
<blockquote>
<p>什么是直接初始化：在对象初始化时，通过括号给对象提供一定的参数，并且要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数</p>
</blockquote>
<h2 id="extern”C”的用法"><a href="#extern”C”的用法" class="headerlink" title="extern”C”的用法"></a>extern”C”的用法</h2><blockquote>
<p>在c++中调用c代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"><span class="comment">//xx.c</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xx.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h2><blockquote>
<p>没有初始化，释放之后没有指向nullptr</p>
</blockquote>
<h2 id="重载，重写，隐藏"><a href="#重载，重写，隐藏" class="headerlink" title="重载，重写，隐藏"></a>重载，重写，隐藏</h2><blockquote>
<p>重载<br>函数名相同，但是参数类型和参数个数不相同</p>
</blockquote>
<blockquote>
<p>重写<br>虚函数多态</p>
</blockquote>
<blockquote>
<p>隐藏<br>继承中的同名函数，子类对象调用父类同名函数需要指定<br>子类.父类::函数<br>如果是父类指针指向派生类对象，没有虚函数指针，无法调用子类同名函数</p>
</blockquote>
<h2 id="C-有哪几种的构造函数"><a href="#C-有哪几种的构造函数" class="headerlink" title="C++有哪几种的构造函数"></a>C++有哪几种的构造函数</h2><blockquote>
<p>默认构造函数<br>初始化构造函数（有参数）<br>拷贝构造函数<br>移动构造函数（move和右值引用）<br>委托构造函数<br>转换构造函数</p>
</blockquote>
<h2 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h2><blockquote>
<p>只拷贝一个指针，没有开辟一个新的地址</p>
</blockquote>
<blockquote>
<p>不仅拷贝值，还分配内存</p>
</blockquote>
<blockquote>
<p>深拷贝防止对象拷贝后悬空指针被二次delete的问题</p>
</blockquote>
<h2 id="如何用代码判断大小端存储？"><a href="#如何用代码判断大小端存储？" class="headerlink" title="如何用代码判断大小端存储？"></a>如何用代码判断大小端存储？</h2><blockquote>
<p>union联合体</p>
</blockquote>
<blockquote>
<p>强转只留下低地址部分</p>
</blockquote>
<h2 id="volatile、mutable和explicit关键字的用法"><a href="#volatile、mutable和explicit关键字的用法" class="headerlink" title="volatile、mutable和explicit关键字的用法"></a>volatile、mutable和explicit关键字的用法</h2><blockquote>
<p>volatile修饰的变量的相关代码不会被优化，提供稳定访问。总是从内存中读取，不会从寄存器中。多线程共享标志</p>
</blockquote>
<blockquote>
<p>mutable修饰的变量可以在const函数中被改变，可以被const对象改变</p>
</blockquote>
<blockquote>
<p>explict修饰的类单参构造函数不允许发生响应的类型到对象的隐式转换</p>
</blockquote>
<h2 id="什么情况下会调用拷贝构造函数"><a href="#什么情况下会调用拷贝构造函数" class="headerlink" title="什么情况下会调用拷贝构造函数"></a>什么情况下会调用拷贝构造函数</h2><ol>
<li>赋值表达式右边是一个对象</li>
<li>直接初始化时，括号内的参数是一个对象</li>
<li>将一个返回类型为引用类型的函数返回一个对象</li>
<li>形参为非引用类型的函数，其中是将实参拷贝到临时对象</li>
</ol>
<h2 id="C-中有几种类型的new"><a href="#C-中有几种类型的new" class="headerlink" title="C++中有几种类型的new"></a>C++中有几种类型的new</h2><blockquote>
<p>plain new  new 抛出bad_alloc</p>
</blockquote>
<blockquote>
<p>nothrow new new(nothrow) 返回null</p>
</blockquote>
<blockquote>
<p>placement new new(p) 不分配内存，只调用构造函数</p>
</blockquote>
<h2 id="C-的异常处理的方法"><a href="#C-的异常处理的方法" class="headerlink" title="C++的异常处理的方法"></a>C++的异常处理的方法</h2><blockquote>
<p>try、throw和catch关键字</p>
</blockquote>
<blockquote>
<p>函数的异常声明列表<br>提前知道函数可能抛出什么异常，提前写出来</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>,A,B,C)</span></span>&#123;...&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不写出来就是默认可能发生任何异常</p>
</blockquote>
<blockquote>
<p>C++标准异常类 exception(不用throw，直接catch就可以)<br>bad_alloc<br>out_of_range<br>bad_typeid<br>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</p>
</blockquote>
<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><blockquote>
<p>p不可以变，*p可以变</p>
</blockquote>
<blockquote>
<p>p可以变，*p不可以变</p>
</blockquote>
<h2 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h2><blockquote>
<p>第一次用到的时候初始化，一次初始化，可以多次赋值，aiexit()管理，main函数结束之后反向析构</p>
</blockquote>
<h2 id="delete-p、delete-p"><a href="#delete-p、delete-p" class="headerlink" title="delete p、delete [] p"></a>delete p、delete [] p</h2><blockquote>
<p>自定义数据类型都一样<br>但是对于自定义数据类型就比较重要</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A* pA = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">delete</span>[]pA;<span class="comment">//输出10次A的析构函数</span></span><br><span class="line">	<span class="comment">//delete pA;//会出错，因为只析构了一次</span></span><br><span class="line"></span><br><span class="line">	A* pA1 = <span class="keyword">new</span> A;</span><br><span class="line">	<span class="keyword">delete</span> pA1;<span class="comment">//输出一次A的析构函数</span></span><br><span class="line">	<span class="comment">//delete[] pA1;//编译器不会报错，但是系统会一直调用析构函数</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="delete是如何知道释放内存的大小的"><a href="#delete是如何知道释放内存的大小的" class="headerlink" title="delete是如何知道释放内存的大小的"></a>delete是如何知道释放内存的大小的</h2><blockquote>
<p>delete[]<br>p-4指向的地址 前4个字节储存数组的大小</p>
</blockquote>
<h2 id="malloc、realloc、calloc的区别"><a href="#malloc、realloc、calloc的区别" class="headerlink" title="malloc、realloc、calloc的区别"></a>malloc、realloc、calloc的区别</h2><blockquote>
<p>malloc随机初始化</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));申请<span class="number">20</span>个<span class="type">int</span>类型的空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>calloc初始化0</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>realloc扩充</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类成员初始化方式？为什么用成员初始化列表会快一些？"><a href="#类成员初始化方式？为什么用成员初始化列表会快一些？" class="headerlink" title="类成员初始化方式？为什么用成员初始化列表会快一些？"></a>类成员初始化方式？为什么用成员初始化列表会快一些？</h2><blockquote>
<p>赋值初始化，列表初始化</p>
</blockquote>
<blockquote>
<p>对于内置类型没什么影响<br>但是对于类类型，列表初始化会比复制初始化多调用一次默认构造函数</p>
</blockquote>
<h2 id="有哪些情况必须用到成员列表初始化？"><a href="#有哪些情况必须用到成员列表初始化？" class="headerlink" title="有哪些情况必须用到成员列表初始化？"></a>有哪些情况必须用到成员列表初始化？</h2><blockquote>
<p>const成员变量，&amp;成员变量不可以赋值，必须列表初始化</p>
</blockquote>
<blockquote>
<p>当调用一个基类的构造函数，而它拥有一组参数时。使用赋值初始化不会报错，但是也不会发生赋值。当调用一个成员类的构造函数，而它拥有一组参数时，同理。</p>
</blockquote>
<blockquote>
</blockquote>
<h2 id="C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h2><blockquote>
<p>封装了char *<br>动态增长，内存不够，换一块*2的内存</p>
</blockquote>
<h2 id="什么是内存泄露，如何检测与避免"><a href="#什么是内存泄露，如何检测与避免" class="headerlink" title="什么是内存泄露，如何检测与避免"></a>什么是内存泄露，如何检测与避免</h2><blockquote>
<p>动态申请的内存未释放</p>
</blockquote>
<blockquote>
<p>new&#x2F;delete new[]&#x2F;delete[] malloc&#x2F;free 成对出现</p>
</blockquote>
<blockquote>
<p>使用智能指针</p>
</blockquote>
<blockquote>
<p>一定要将基类的析构函数声明为虚函数</p>
</blockquote>
<h2 id="基类析构函数为什么要定义为虚函数"><a href="#基类析构函数为什么要定义为虚函数" class="headerlink" title="基类析构函数为什么要定义为虚函数"></a>基类析构函数为什么要定义为虚函数</h2><blockquote>
<p>当基类指针指向派生类的时候，若基类析构函数不声明为虚函数，在析构时，只会调用基类而不会调用派生类的析构函数，从而导致内存泄露。析构寒素名虽然都不一样，但是编译器对析构函数名做了特殊的处理，全部为destructor，函数名一样，自然被隐藏。</p>
</blockquote>
<h2 id="对象复用的了解"><a href="#对象复用的了解" class="headerlink" title="对象复用的了解"></a>对象复用的了解</h2><blockquote>
<p>本质就是设计模式中的flyweight享元模式。通过将对象存储到对象池中对对象进行复用，避免多次构造和析构重复对象的开销</p>
</blockquote>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><blockquote>
<p>封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。友元<br>继承：它可以使用一个类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行使用。派生类，父类。三种权限继承。<br>多态(重写，重载)：允许父类指针指向子类对象，根据子类对象不同调用相同方法，出现不同结果。</p>
</blockquote>
<h2 id="C-的四种强制转换"><a href="#C-的四种强制转换" class="headerlink" title="C++的四种强制转换"></a>C++的四种强制转换</h2><blockquote>
<p>static_cast 主要用于基本数据类型的转换，但是不能转换调数据类型中的const,volitale等属性<br>也可以用于基类和派生类之间指针和引用的转换<br>上行转换是安全的，但是下行转换没有动态类型检测是不安全的。<br>又或者指针，空指针转换<br>const_cast<br>const_cast&lt;&gt;里边的内容必须是引用或者指针。连int转int都不可以，修改常量不推荐</p>
</blockquote>
<blockquote>
<p>reinterpret_cast<br>指针，引用，算数类型之间转换<br>比如指针相互相互转换，获得地址中存储数据的解释权。地址中存储的是一个数字，int指针读的话是一个数字，但是char指针读的话就是字符了。又或者int转<br>int*，直接访问不允许的地址，段错误。</p>
</blockquote>
<blockquote>
<p>dynamic_cast</p>
</blockquote>
<ol>
<li>其他三种都是编译时完成的，dynamic_cast 是运行时处理的，运行时要进行类型检查。</li>
<li>不能用于内置的基本数据类型的强制转换</li>
<li>dynamic_cast 要求 &lt;&gt; 内所描述的目标类型必须为指针或引用。dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr</li>
<li>上行转换都一样。但是下行转换，static_cast不安全，能通过，但实际使用可能报错。dynamic_cast首先使用基类必须有虚函数，负责无法通过编译。即使有基类的指针也必须真的指向派生类的对象才能转换，否则报错。</li>
</ol>
<h2 id="写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h2><blockquote>
<p>创建段错误输出的文件，编译时加上，还有-g<br>出错后gdb调试</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="说说移动构造函数"><a href="#说说移动构造函数" class="headerlink" title="说说移动构造函数"></a>说说移动构造函数</h2><blockquote>
<p>为了实现对右值的完美转发。<br>构造函数的形参如果是一个左值引用，它可以接收一个左值，指向和这个左值一样的地址，让和让实参左值的指针指向nullptr,这样析构的时候就不会对同一片地址释放两次，又只消耗了一份内存资源。但是一个左值引用形参无法接收一个右值实参。const左值引用可以接收右值，但是这就意味之不能让指针指向nullptr，所以这样。<br>同时为了左值和右值可以复用同一份代码实现完美转发，move（）可以将左值转化没右值</p>
</blockquote>
<h2 id="C-中将临时变量作为返回值时的处理过程"><a href="#C-中将临时变量作为返回值时的处理过程" class="headerlink" title="C++中将临时变量作为返回值时的处理过程"></a>C++中将临时变量作为返回值时的处理过程</h2><blockquote>
<p>函数结束时临时变量就被销毁，内存空间不再属于历史变量，但是这个返回值其实保存在寄存器中，赋值语句接收就可以了。</p>
</blockquote>
<h2 id="如何获得结构成员相对于结构开头的字节偏移量"><a href="#如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="如何获得结构成员相对于结构开头的字节偏移量"></a>如何获得结构成员相对于结构开头的字节偏移量</h2><blockquote>
<p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。<br>offsetof(结构名，结构成员名);</p>
</blockquote>
<h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><blockquote>
<p>在继承的体系中只有虚函数是动态绑定，其他都是静态绑定</p>
</blockquote>
<blockquote>
<p>在静态绑定中一个指针调用一个函数，如果这个函数是一个非虚函数那么对这个函数的调用是由这个指针的编译期的静态类型决定的，他的动态类型是什么无关紧要，哪怕是nullptr,依旧可以正常调用，不会发生空指针。在编译期就确定好了。</p>
</blockquote>
<blockquote>
<p>调用虚函数则看动态绑定的是啥，运行期。</p>
</blockquote>
<h2 id="虚函数与默认形参"><a href="#虚函数与默认形参" class="headerlink" title="虚函数与默认形参"></a>虚函数与默认形参</h2><blockquote>
<p>默认值是在编译期确定的，编译期发现函数参数缺失，补充静态绑定的类型的函数的形参默认值，调用的函数是在运行的时候决定的</p>
</blockquote>
<h2 id="引用是否能实现动态绑定，为什么可以实现？"><a href="#引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="引用是否能实现动态绑定，为什么可以实现？"></a>引用是否能实现动态绑定，为什么可以实现？</h2><blockquote>
<p>就是初始化的时候不可以用new的方式，必须创建一个子类对象，然后用这个子类对象赋值。</p>
</blockquote>
<blockquote>
<p>在汇编的层面是上都是地址的概念。this指针，虚函数指针，虚表，调用函数。虚函数才是关键</p>
</blockquote>
<h2 id="全局变量和局部变量有什么区别？"><a href="#全局变量和局部变量有什么区别？" class="headerlink" title="全局变量和局部变量有什么区别？"></a>全局变量和局部变量有什么区别？</h2><blockquote>
<p>生命周期和存放位置</p>
</blockquote>
<h2 id="指针加减计算要注意什么？"><a href="#指针加减计算要注意什么？" class="headerlink" title="指针加减计算要注意什么？"></a>指针加减计算要注意什么？</h2><blockquote>
<p>加减都要乘或除类型所占字节数</p>
</blockquote>
<h2 id="怎样判断两个浮点数是否相等？"><a href="#怎样判断两个浮点数是否相等？" class="headerlink" title="怎样判断两个浮点数是否相等？"></a>怎样判断两个浮点数是否相等？</h2><blockquote>
<p>对于浮点数的判断由于精度的限制不可以用&#x3D;&#x3D;或者！&#x3D;判断，应该全部转换成&gt;&#x3D;,&lt;&#x3D;.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> eps=<span class="number">10e-9</span>;<span class="comment">//设置绝对误差阈值，当两个数绝对误差很小很小的时候，就认为两者相等；</span></span><br><span class="line"><span class="type">double</span> releps=<span class="number">10e-4</span>;<span class="comment">//设置相对误差阈值，当两个数的相对误差很小的时候，认为相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEqual</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b , <span class="type">double</span> eps,<span class="type">double</span> releps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(a-b)&lt;eps)</span><br><span class="line">	&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(a-b)&lt;=releps*<span class="built_in">fabs</span>(a))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>和0比较也需要转化为</p>
</blockquote>
<pre><code>if (x == 0.0) // 隐含错误的比较
转化为
if ((x&gt;=-EPSINON) &amp;&amp; (x&lt;=EPSINON))
</code></pre>
<h2 id="如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>如果想将某个类用作基类，为什么该类必须定义而非声明？</h2><p>派生类可以使用从基类那里继承来的一切，它总需要知道它到底继承了一些什么东西</p>
<h2 id="继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>继承机制中对象之间如何转换？指针和引用之间如何转换？</h2><blockquote>
<p>向上类型转换<br>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</p>
</blockquote>
<blockquote>
<p>向下类型转换<br>向下类型转换不安全，RTTI技术，用dynamic_cast进行向下类型转换</p>
</blockquote>
<h2 id="C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h2><blockquote>
<p>指针参数传递本质是上还是一个值传递。只不过传递的是指针实参的地址。对形参地址上保存的数据进行改变会影响到实参，但是单纯的改变地址，不会对实参的地址产生影响。但是引用参数传递，栈中存放的实参变量的地址，任何对形参的操作都会间接寻址到实参。</p>
</blockquote>
<h2 id="C-如何实现类对象只能动态分配或只能静态分配"><a href="#C-如何实现类对象只能动态分配或只能静态分配" class="headerlink" title="C++如何实现类对象只能动态分配或只能静态分配"></a>C++如何实现类对象只能动态分配或只能静态分配</h2><blockquote>
<p>只能动态分配<br>将构造函数和析构函数的访问权限都设置成protect,这样类外无法直接访问构造函数，只能通过new,而且可以实现继承，子类可以访问</p>
</blockquote>
<pre><code>class A  
&#123;  
protected:  
     A()&#123;&#125;  
     ~A()&#123;&#125;  
public:  
     static A* create()&#123;return new A();&#125; // 建立对象
     void destory()&#123;delete this;&#125;  //释放内存
&#125;;  
</code></pre>
<blockquote>
<p>静态分配<br>将new设置成访问权限设置成私有</p>
</blockquote>
<pre><code>class A  
&#123;  
private:  
     void* operator new(size_t t)&#123;&#125;          //注意函数的第一个参数和返回值都是固定的  
     void operator delete(void* ptr)&#123;&#125;       //重载了new就需要重载delete  
public:  
     A()&#123;&#125;  
     ~A()&#123;&#125;  
&#125;;  
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011692048/article/details/79503694">https://blog.csdn.net/u011692048/article/details/79503694</a></p>
</blockquote>
<h2 id="知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>知道C++中的组合吗？它与继承相比有什么优缺点吗？</h2><blockquote>
<p>继承是is-a，一个类继承一个类。父类中细节对子类可见，并且高耦合。组合是has-a，一个类包含一个类，被包含类中细节对包含类不可见，并且低耦合。但是大类由各种小类组合而成，类容易过多。</p>
</blockquote>
<h2 id="为什么要有函数指针-直接调用不可以么"><a href="#为什么要有函数指针-直接调用不可以么" class="headerlink" title="为什么要有函数指针,直接调用不可以么"></a>为什么要有函数指针,直接调用不可以么</h2><blockquote>
<p>直接调用的确可以，但是代码的结构并不好。<br>函数指针数组储存函数指针，传入参数数组中的数据，一个循环就搞定，就是得一一对应调整好。直接调用就必须if-else<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinchi_boke/article/details/118065628">https://blog.csdn.net/jinchi_boke/article/details/118065628</a></p>
</blockquote>
<blockquote>
<p>形参不可以是函数，但是可以使函数指针。回调之类的</p>
</blockquote>
<h2 id="结构体变量比较是否相等"><a href="#结构体变量比较是否相等" class="headerlink" title="结构体变量比较是否相等"></a>结构体变量比较是否相等</h2><blockquote>
<p>重载运算符</p>
</blockquote>
<h2 id="你知道printf函数的实现原理是什么吗？"><a href="#你知道printf函数的实现原理是什么吗？" class="headerlink" title="你知道printf函数的实现原理是什么吗？"></a>你知道printf函数的实现原理是什么吗？</h2><blockquote>
<p>参数从右往左压栈，根据参数类型和个数，判断输出数据的大小和偏移量</p>
</blockquote>
<h2 id="cout和printf有什么区别？"><a href="#cout和printf有什么区别？" class="headerlink" title="cout和printf有什么区别？"></a>cout和printf有什么区别？</h2><blockquote>
<p>首先他们都有缓冲区。print有的，换行或者程序结束输出</p>
</blockquote>
<blockquote>
<p>排除性能差异。不需要应对输出数据的类型</p>
</blockquote>
<h2 id="C-中类成员的访问权限和继承权限问题"><a href="#C-中类成员的访问权限和继承权限问题" class="headerlink" title="C++中类成员的访问权限和继承权限问题"></a>C++中类成员的访问权限和继承权限问题</h2><blockquote>
<p>public  protect private</p>
</blockquote>
<blockquote>
<p>访问权限不必说</p>
</blockquote>
<blockquote>
<p>继承权限<br>public 父类中的访问权限都不变<br>private 父类中的访问权限全private<br>protect 父类中的访问权限private不变，其他全protect</p>
</blockquote>
<h2 id="当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>当程序中有函数重载时，函数的匹配原则和顺序是什么？</h2><blockquote>
<p>名字查找，候选函数，最佳匹配</p>
</blockquote>
<h2 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h2><blockquote>
<p>变量：有这么一个变量存在但是没有分配内存<br>函数:有这么一个函数但是没有实现</p>
</blockquote>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><blockquote>
<p>类内重载做成员函数，内外重载做友元函数</p>
</blockquote>
<pre><code>class Point&#123;
public:
    Point()&#123;&#125;;
    Point (int x, int y): x(x),y(y) &#123;&#125;;
    Point operator+(const Point &amp;b)&#123; 
    //类内重载，运算符重载函数作为类的成员函数
        Point ret;
        ret.x = this-&gt;x + b.x;
        ret.y = this-&gt;y + b.y;
        return ret;
    &#125;
    int x,y;
&#125;;

public:
    Point()&#123;&#125;;
    Point (int x, int y): x(x),y(y) &#123;&#125;;
    friend Point operator+(const Point &amp;, const Point &amp;);   
    //声明类的友元函数
    int x,y;
&#125;;

Point operator+(const Point &amp;a,const Point &amp;b)&#123;
//类外重载,运算符重载函数作为类的友元函数
    Point ret;
    ret.x = a.x + b.x;
    ret.y = a.y + b.y;
    return ret;
&#125;
</code></pre>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载&lt;&lt;"></a>重载&lt;&lt;</h2><pre><code>friend ostream &amp;operator&lt;&lt;(ostream &amp;out , const Point &amp;a);  
//如果是重载双目操作符（即为类的成员函数），就只要设置一个参数作为右侧运算量，而左侧运算量就是对象本身。。。。。。
而 &gt;&gt;  或&lt;&lt; 左侧运算量是 cin或cout 而不是对象本身，所以不满足后面一点。。。。。。。。就只能申明为友元函数了。。。

//&lt;&lt; 运算符重载的函数实现   ostream是输入输出流的类
ostream &amp;operator&lt;&lt;(ostream &amp;out , const Point &amp;a)&#123;
    out &lt;&lt; &quot;&lt;Point&gt;( &quot; &lt;&lt; a.x &lt;&lt; &quot;, &quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;;
    return out;
&#125;


//一定要搞成成员函数
ostream &amp; operator&lt;&lt;(ostream &amp;output)
&#123;
　　return output;
&#125;
所以在运用这个&lt;&lt;运算符时就变为这种形式了：data&lt;&lt;cout;
不符合习惯也不可以链式调用
</code></pre>
<h2 id="重载前置-，后置"><a href="#重载前置-，后置" class="headerlink" title="重载前置++，后置++"></a>重载前置++，后置++</h2><pre><code>Point&amp; operator++()&#123; //前置++运算符，需要引用返回，不需要参数。返回自增后的值，且返回的是一个左值 
        this-&gt;x ++;
        this-&gt;y ++;
        return *this;
    &#125;
     //const 修饰返回值不能修改  
    const Point operator++(int)&#123;//后置++，不需要引用返回，需要参数区分。返回自增前的值，且返回的是一个右值
        Point temp(x,y);       //因为后置++，是先使用，后自++，所以这里要保存一个临时值，再++，返回的是临时值。
        this-&gt;x ++;
        this-&gt;y ++;
        return temp;
    &#125;
</code></pre>
<h2 id="重载-1"><a href="#重载-1" class="headerlink" title="重载&#x3D;"></a>重载&#x3D;</h2><blockquote>
<p>默认等于是浅拷贝，自定义类型有指针，需要重载，深拷贝</p>
</blockquote>
<h2 id="如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>如何在不使用额外空间的情况下，交换两个数？你有几种方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  算术</span><br><span class="line">x = x + y;</span><br><span class="line">y = x - y;</span><br><span class="line">x = x - y; </span><br></pre></td></tr></table></figure>

<h2 id="隐式转换，如何消除隐式转换？"><a href="#隐式转换，如何消除隐式转换？" class="headerlink" title="隐式转换，如何消除隐式转换？"></a>隐式转换，如何消除隐式转换？</h2><blockquote>
<p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
</blockquote>
<h2 id="条件编译，头文件重复包含的问题"><a href="#条件编译，头文件重复包含的问题" class="headerlink" title="条件编译，头文件重复包含的问题"></a>条件编译，头文件重复包含的问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAD_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是头文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEAD_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中，HEAD_H_INCLUDED 是一个标识符，它可以是任何有效的标识符。当头文件第一次被包含时，HEAD_H_INCLUDED 这个宏没有被定义，因此编译器会编译 #ifndef 到 #endif 之间的代码块（即头文件内容）。而当头文件在其他源文件中再次被包含时，由于 HEAD_H_INCLUDED 这个宏已经被定义了，因此编译器会跳过整个代码区域，从而避免了重复定义的问题。</p>
</blockquote>
<h2 id="程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h2><blockquote>
<p>右到左 入栈<br>argc个参数，argv数组第一个是程序名</p>
</blockquote>
<h2 id="如果有一个空类，它会默认添加哪些函数？"><a href="#如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="如果有一个空类，它会默认添加哪些函数？"></a>如果有一个空类，它会默认添加哪些函数？</h2><blockquote>
<p>默认生成的函数只有在被需要的时候才会产生<br>默认缺省构造函数、默认析构函数、默认拷贝构造函数、赋值运算符、取址运算符、const取址运算符</p>
</blockquote>
<h2 id="string、char-、const-char"><a href="#string、char-、const-char" class="headerlink" title="string、char 、const char"></a>string、char <em>、const char</em></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a)  <span class="built_in">string</span>转<span class="type">const</span> <span class="type">char</span>* 用一个函数</span><br><span class="line">    <span class="built_in">string</span> s = “abc”; </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* c_s = s.c_str(); </span><br><span class="line">b)  <span class="type">const</span> <span class="type">char</span>* 转<span class="built_in">string</span>，直接赋值即可 </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* c_s = “abc”; </span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">s</span><span class="params">(c_s)</span>; </span><br><span class="line">c)  <span class="built_in">string</span> 转<span class="type">char</span>* 本质是<span class="type">const</span> <span class="type">char</span> *转<span class="type">char</span> *</span><br><span class="line">    <span class="built_in">string</span> s = “abc”; </span><br><span class="line">    <span class="type">char</span> *c = new <span class="type">char</span>[s.length()+<span class="number">1</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(c,s.c_str()); </span><br><span class="line">d)  <span class="type">char</span>* 转<span class="built_in">string</span>  直接赋值</span><br><span class="line">    <span class="type">char</span>* c = “abc”; </span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">s</span><span class="params">(c)</span>; </span><br><span class="line">e)  <span class="type">const</span> <span class="type">char</span>* 转<span class="type">char</span>* </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cpc = “abc”; </span><br><span class="line">    <span class="type">char</span>* pc = new <span class="type">char</span>[<span class="built_in">strlen</span>(cpc)+<span class="number">1</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(pc,cpc);</span><br><span class="line"></span><br><span class="line">f)  <span class="type">char</span>* 转<span class="type">const</span> <span class="type">char</span>*，直接赋值即可 </span><br><span class="line">    <span class="type">char</span>* pc = “abc”; </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br></pre></td></tr></table></figure>

<h2 id="如何设计一个计算仅单个子类的对象个数？"><a href="#如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="如何设计一个计算仅单个子类的对象个数？"></a>如何设计一个计算仅单个子类的对象个数？</h2><blockquote>
<p>静态成员变量<br>各个构造函数+1.析构函数-1</p>
</blockquote>
<h2 id="如何阻止一个类被实例化？有哪些方法？"><a href="#如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="如何阻止一个类被实例化？有哪些方法？"></a>如何阻止一个类被实例化？有哪些方法？</h2><blockquote>
<p>声明纯虚函数，定义抽象类</p>
</blockquote>
<h2 id="如何禁止程序自动生成拷贝构造函数？"><a href="#如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="如何禁止程序自动生成拷贝构造函数？"></a>如何禁止程序自动生成拷贝构造函数？</h2><blockquote>
<p>将拷贝构造函数访问权限设置成private,将拷贝构造函数和复制运算符重载设置成delete</p>
</blockquote>
<h2 id="你知道Debug和Release的区别是什么吗？"><a href="#你知道Debug和Release的区别是什么吗？" class="headerlink" title="你知道Debug和Release的区别是什么吗？"></a>你知道Debug和Release的区别是什么吗？</h2><blockquote>
<p>调试版本和发布版本。没有什么本质的不同，前者大一些，多了调试信息。但都是不同编译选项的结构，你如果想，可以随便修改</p>
</blockquote>
<h2 id="main函数的返回值有什么值得考究之处吗？"><a href="#main函数的返回值有什么值得考究之处吗？" class="headerlink" title="main函数的返回值有什么值得考究之处吗？"></a>main函数的返回值有什么值得考究之处吗？</h2><blockquote>
<p>0 或者void表示正常退出<br>大于0除了问题，具体情况具体分析<br>返回给进程</p>
</blockquote>
<h2 id="为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>为什么C++没有垃圾回收机制？这点跟Java不太一样。</h2><blockquote>
<p>c++是偏向底层的语言，垃圾回收机制带来的便利相比与它可能带来的的性能损耗还是代价太大</p>
</blockquote>
<h2 id="成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="成员函数里memset(this,0,sizeof(*this))会发生什么"></a>成员函数里memset(this,0,sizeof(*this))会发生什么</h2><blockquote>
<p>将对象的内存全部变为0，也就是将成员变量一次性都初始化为0，看似是十分的方便，但是却有问题，如果类有虚表就会破坏表结构，虚函数的调用就会出现异常，</p>
</blockquote>
<h2 id="C-从代码到可执行程序经历了什么？"><a href="#C-从代码到可执行程序经历了什么？" class="headerlink" title="C++从代码到可执行程序经历了什么？"></a>C++从代码到可执行程序经历了什么？</h2><ul>
<li>预编译<ul>
<li>删除注释、处理条件编译、宏展开和include包含、添加行号和文件标识，生成.i文件</li>
</ul>
</li>
<li>编译<ul>
<li>词法分析【分割字符】、语法分析【生成语法树】、语义分析【检查语法有没有有错误】、生成源代码.s文件</li>
</ul>
</li>
<li>汇编<ul>
<li>翻译成汇编指令，生成目标.o文件</li>
</ul>
</li>
<li>链接<ul>
<li>将不同源文件产生的目标文件链接成一个可执行文件。分为静态链接和动态链接</li>
<li>静态库直接嵌入可执行文件。空间浪费，每个可执行问件都有所需静态库的副本；更新困难，静态库一变就需要重新链接。但是执行速度快。</li>
<li>程序运行时才链接到动态库。共享库不会有那么多副本造成空间浪费；更新容易，只需要更新动态库，不需要再链接一次。但是执行速度相对较慢</li>
</ul>
</li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><blockquote>
<p>为了让一个函数或者一个类可以访问另一个类中的私有成员。友元声明必须在被访问私有成员的类中声明。</p>
</blockquote>
<blockquote>
<p>全员函数和类做友元都还可以</p>
</blockquote>
<blockquote>
<p>成员函数做友元<br>必须这样的顺序<br>首先声明被友元的类，然后定义友元成员函数的类，但是友元成员函数只可以声明，同时在类中声明被友元的类的对象。然后定义被友元的类包括对于友元成员函数的友元声明。最后定义友元成员函数</p>
</blockquote>
<h2 id="类的对象存储空间？"><a href="#类的对象存储空间？" class="headerlink" title="类的对象存储空间？"></a>类的对象存储空间？</h2><blockquote>
<p>非静态成员的数据类型大小之和。编译器加入的额外成员变量（如指向虚函数表的指针）.为了边缘对齐优化加入的padding。空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0</p>
</blockquote>
<h2 id="为什么空类的大小是1"><a href="#为什么空类的大小是1" class="headerlink" title="为什么空类的大小是1"></a>为什么空类的大小是1</h2><blockquote>
<p>为了空类实例化的时候有自己的地址，否则你创建一个空类对象的数组，不同的对象却有着相同的地址。</p>
</blockquote>
<h2 id="简要说明C-的内存分区"><a href="#简要说明C-的内存分区" class="headerlink" title="简要说明C++的内存分区"></a>简要说明C++的内存分区</h2><blockquote>
<p>低地址到高地址<br>代码区、常量存储区、全局\静态存储区、堆区、未使用内存、栈区</p>
</blockquote>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><blockquote>
<p>默认的内存管理操作符 new&#x2F;delete 和函数 malloc()&#x2F;free() 在堆上分配和释放内存会有一些额外的开销。申请的内存大小不定，重复的分割或者合并空闲内存块会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，预先申请分配一定数量、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升。</p>
</blockquote>
<blockquote>
<p>单线程\多线程内存池 固定\可变内存池(每次分配的内存单元大小是否按需分配)</p>
</blockquote>
<blockquote>
<p>链表连接内存块</p>
</blockquote>
<h2 id="C-中类的数据成员和成员函数内存分布情况"><a href="#C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="C++中类的数据成员和成员函数内存分布情况"></a>C++中类的数据成员和成员函数内存分布情况</h2><blockquote>
<p>数据成员类比结构体<br>函数全在代码区，无论是全局函数、成员函数、静态函数</p>
</blockquote>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><blockquote>
<p>类的指针、指向对象的首地址，只有在非静态成员函数中才可以使用，作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p>
</blockquote>
<blockquote>
<p>非静态成员函数在编译器看来的样子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;public:	int func(int p)&#123;&#125;&#125;;//一个类</span><br><span class="line">//真实是</span><br><span class="line">int func(A * const this,int p);</span><br><span class="line"></span><br><span class="line">A a;a.func(10);//此处，编译器将会编译成：A::func(&amp;a,10);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>this在成员函数的开始执行前构造,大多数编译器通过ecx（寄数寄存器）寄存器传递this指针.非静态成员函数的首参数就是this指针。访问成员变量的方式类比结构体指针取结构体成员。我们无法获得this指针的地址，一般来说我们只有在非静态成员函数中才会用到this指针，但是this指针一般是一个右值。</p>
</blockquote>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><blockquote>
<p>不是指某段内存在物理上消失，而是指在分配某段内存后失去了对某段内存的控制</p>
</blockquote>
<blockquote>
<p>建议使用智能指针</p>
</blockquote>
<h2 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h2><blockquote>
<p>对象的内存空间将被释放，成员变量和虚函数表将不复存在。如果不涉及操作成员变量和访问虚函数就没有问题，否则将产生不可预期的的问题，因为内存并没有立马被回收，你还可以访问，但是结果不确定，可能得到乱码，可能程序崩溃</p>
</blockquote>
<h2 id="如果在类的析构函数中调用delete-this，会发生什么？"><a href="#如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="如果在类的析构函数中调用delete this，会发生什么？"></a>如果在类的析构函数中调用delete this，会发生什么？</h2><blockquote>
<p>delete this会调用对象的析构函数，然后无限递归，程序崩溃</p>
</blockquote>
<h2 id="auto-推导类型，必须有初始值"><a href="#auto-推导类型，必须有初始值" class="headerlink" title="auto 推导类型，必须有初始值"></a>auto 推导类型，必须有初始值</h2><blockquote>
<p>推导顶层const和底层const的问题<br>auto会忽略顶层const</p>
</blockquote>
<pre><code>const int i = 5;
auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int
const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt
</code></pre>
<blockquote>
<p>也会忽略引用</p>
</blockquote>
<pre><code>int x = 2;
int&amp; y = x;
auto z = y; //z是int型不是int&amp; 型
auto&amp; p1 = y; //p1是int&amp;型
</code></pre>
<blockquote>
<p>对常量取地址是一种底层const</p>
</blockquote>
<h2 id="decltype返回操作数的数据类型"><a href="#decltype返回操作数的数据类型" class="headerlink" title="decltype返回操作数的数据类型"></a>decltype返回操作数的数据类型</h2><blockquote>
<p>无论是顶层const，还是底层const都不会忽略，全部保留</p>
</blockquote>
<blockquote>
<p>对指针的解引用操作返回的是引用类型</p>
</blockquote>
<pre><code>int i = 3, j = 6, *p = &amp;i;
decltype(*p) c = j; // c是int&amp;类型, c和j绑定在一起
</code></pre>
<blockquote>
<p>如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</p>
</blockquote>
<pre><code>如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了
</code></pre>
<h2 id="decltype-auto-c-14"><a href="#decltype-auto-c-14" class="headerlink" title="decltype(auto) c++14"></a>decltype(auto) c++14</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int e = 4;</span><br><span class="line">const int* f = &amp;e; // f是底层const</span><br><span class="line">decltype(auto) j = f;//j的类型是const int* 并且指向的是e</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>auto会由等号右边的表达式替换</p>
</blockquote>
<h2 id="C-中NULL和nullptr区别"><a href="#C-中NULL和nullptr区别" class="headerlink" title="C++中NULL和nullptr区别"></a>C++中NULL和nullptr区别</h2><blockquote>
<p>推荐使用nullptr,在c++中null默认为0，可能会发生函数重载匹配错误的问题</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(char* p) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;char*&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int p) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fun(NULL);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果：int</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>nullptr可以转换成任何指针类型，但是不会转换成整形</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(char* p)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;char* p&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void fun(int* p)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;int* p&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int p)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;int p&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    fun((char*)nullptr);//语句1</span><br><span class="line">	fun(nullptr);//语句2</span><br><span class="line">    fun(NULL);//语句3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果：</span><br><span class="line">//语句1：char* p</span><br><span class="line">//语句2:报错，有多个匹配</span><br><span class="line">//3：int p</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><blockquote>
<p>包括算法、容器、迭代器</p>
</blockquote>
<blockquote>
<p>排序、查找等常用算法。以及各个容器的特有算法</p>
</blockquote>
<blockquote>
<p>序列式容器和关联式容器。vector,stack等map,set等</p>
</blockquote>
<blockquote>
<p>不暴露容器结构的情况下对容器的遍历</p>
</blockquote>
<h2 id="trivial-destructor"><a href="#trivial-destructor" class="headerlink" title="trivial destructor"></a>trivial destructor</h2><blockquote>
<p>如果用户不定义析构函数，而是系统自带的，那么说明析构函数基本没什么用（但默认会被调用）。我们称之为trivial destructor。反之，如果特别定义了析构函数，则说明需要在释放空间之前做一些事情，则这个析构函数称之为non-trivial destructor。如果某个类中只有基本类型的话是没有必要调用析构函数的，delete的时候基本不会产生析构代码。<br>在STL根据迭代器指向对象的类别，决定使用哪个版本的destroy().减少多次调用无用析构函数带来的性能损耗</p>
</blockquote>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><blockquote>
<p>利用对象生命周期控制资源的简单技术。对象构造时获取资源，对象析构时释放资源。不仅不需要显式的释放资源，而且所需要的资源在对象生命周期内始终有效。</p>
</blockquote>
<h2 id="RAII的代表智能指针"><a href="#RAII的代表智能指针" class="headerlink" title="RAII的代表智能指针"></a>RAII的代表智能指针</h2><blockquote>
<p>智能指针不是指针，而是帮助我们管理指针的对象。由于c++没有内存回收机制，我们必须显式delete我们new出来的内存，但是由于各种情况可能会忘记delete或者多次delete导致内存泄露等问题。比如函数因为return提前退出没有delete,循环因为continue或者break提前退出没有delete.所以智能指针来帮助我们管理内存。智能指针的对象都是栈上的，所以被管理的内存会在函数或者程序结束时自动释放。</p>
</blockquote>
<h2 id="智能指针分类"><a href="#智能指针分类" class="headerlink" title="智能指针分类"></a>智能指针分类</h2><blockquote>
<p>auto_ptr</p>
</blockquote>
<ul>
<li>用于C98中但是C++11已经废弃。存在很多缺点 不可以赋值和拷贝，会失去对原指针的管理，但是使用的话又不会报错。因此不可以成为容器对象。同时不可以管理数组指针，因为析构函数中释放对象使用的delete,会内存泄露</li>
</ul>
<blockquote>
<p>unique_ptr</p>
</blockquote>
<ul>
<li><p>C++11中用于替代auto_ptr.禁止拷贝构造和赋值，使用会报错。但是可以用移动构造函数，std::move().并且可以管理数组指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">p1</span><span class="params">(new <span class="type">int</span>(<span class="number">5</span>))</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; p2 = p1; <span class="comment">// 编译会出错</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">std</span>::move(p1);</span><br><span class="line"><span class="comment">// 转移所有权, 现在那块内存归p3所有, p1成为无效的指针.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>share_ptr</p>
</blockquote>
<ul>
<li>多个指针指向相同的对象。use_count查计数，release释放指针，返回指针所有权。reset放弃指针所有权。循环引用问题weak_ptr解决，多线程读写需要加锁</li>
</ul>
<blockquote>
<p>weak_ptr</p>
</blockquote>
<ul>
<li>解决两个share_ptr互相引用产生循环引用死锁，计数永远降不到0，没办法进行资源释放，造成内存泄漏的问题。使用时配合share_ptr使用，把其中一个share_ptr更换为weak_ptr。</li>
</ul>
<h2 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h2><blockquote>
<p>强引用知道引用计数，也修改引用计数，同时参与对内存的管理。弱引用都不参与，不过可以知道对象知否已经释放，避免访问非法内存</p>
</blockquote>
<h2 id="智能指针和普通指针的区别"><a href="#智能指针和普通指针的区别" class="headerlink" title="智能指针和普通指针的区别"></a>智能指针和普通指针的区别</h2><blockquote>
<p>指针是一种数据类型，保存的是内存的地址。而智能指针则是为其提供了一层封装，是一种管理指针的类</p>
</blockquote>
<h2 id="智能指针有没有内存泄露的情况"><a href="#智能指针有没有内存泄露的情况" class="headerlink" title="智能指针有没有内存泄露的情况"></a>智能指针<code>有没有</code>内存泄露的情况</h2><blockquote>
<p>智能指针有内存泄露的情况：</p>
</blockquote>
<p>当两个类对象中各自有一个 shared_ptr 指向对方时，会造成循环引用，使引用计数失效，从而导致内存泄露。<br>为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
<h2 id="weak-ptr-如何解决-shared-ptr-的循环引用问题？"><a href="#weak-ptr-如何解决-shared-ptr-的循环引用问题？" class="headerlink" title="weak_ptr 如何解决 shared_ptr 的循环引用问题？"></a>weak_ptr 如何解决 shared_ptr 的循环引用问题？</h2><blockquote>
<p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数，依此特性可以解决 shared_ptr 的循环引用问题。<br>weak_ptr 没有解引用 * 和获取指针 -&gt; 运算符，它只能通过 lock 成员函数去获取对应的 shared_ptr 智能指针对象，从而获取对应的地址和内容。<br>不论是否有 weak_ptr 指向，一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。</p>
</blockquote>
<h2 id="智能指针是否线程安全"><a href="#智能指针是否线程安全" class="headerlink" title="智能指针是否线程安全?"></a>智能指针是否线程安全?</h2><blockquote>
<p>shared_ptr对象提供与内置类型相同级别的线程安全性:</p>
</blockquote>
<ol>
<li>同一个shared_ptr对象可以被多个线程同时读;</li>
<li>不同的shared_ptr对象可以被多个线程同时修改,即使这些shared_ptr对象管理着同一个对象的指针.</li>
<li>同一个shared_ptr对象不能被多线程直接修改，但可以通过原子函数完成,std::atomic 类型和其对应的原子操作函数</li>
</ol>
<h2 id="https-blog-csdn-net-haimianjie2012-article-details-104818736"><a href="#https-blog-csdn-net-haimianjie2012-article-details-104818736" class="headerlink" title="https://blog.csdn.net/haimianjie2012/article/details/104818736"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/haimianjie2012/article/details/104818736">https://blog.csdn.net/haimianjie2012/article/details/104818736</a></h2><h2 id="C-11-lambda表达式的捕捉方式有哪几种"><a href="#C-11-lambda表达式的捕捉方式有哪几种" class="headerlink" title="C++11 lambda表达式的捕捉方式有哪几种"></a>C++11 lambda表达式的捕捉方式有哪几种</h2><blockquote>
<p>值捕获，不可以修改被捕获的变量 除非加mutable属性<br>引用捕获<br>隐式捕获 &#x3D; &amp;<br>混合方式</p>
</blockquote>
<p><img src="https://img1.imgtp.com/2023/05/07/lO9kwkQI.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/12/g1BA9cZE.png" alt="image" loading="lazy"></p>
<blockquote>
<p>易读性高，节省内存，可以赋值,必须使用auto</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>回调函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">const</span> std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&amp; func)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">func</span>(a, b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">1</span>, <span class="number">2</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迭代器：-it、it-哪个好，为什么"><a href="#迭代器：-it、it-哪个好，为什么" class="headerlink" title="迭代器：++it、it++哪个好，为什么"></a>迭代器：++it、it++哪个好，为什么</h2><blockquote>
<p>++it<br>前者好一点。前者直接返回引用，或者返回临时对象。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// ++i实现代码为：</span><br><span class="line">int&amp; operator++()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  *this += 1;</span><br><span class="line">  return *this;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">//i++实现代码为：                 </span><br><span class="line">int operator++(int)                 </span><br><span class="line">&#123;</span><br><span class="line">int temp = *this;                   </span><br><span class="line"></span><br><span class="line">   ++*this;                       </span><br><span class="line"></span><br><span class="line">   return temp;                  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><blockquote>
<p>左值引用即使一般的引用</p>
</blockquote>
<blockquote>
<p>右值引用关联到右值时，右值储存到特定位置。右值无法获取地址，但是右值引用可以获取地址,这个地址就是临时对象的存储位置</p>
</blockquote>
<blockquote>
<p>右值被右值引用后生命周期和右值引用类型的变量一样长</p>
</blockquote>
<blockquote>
<p>右值引用独立于左值和右值，可以是左值，也可以是右值</p>
</blockquote>
<blockquote>
<p>T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void func(int&amp;&amp; i) &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int&amp; i) &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int x = 0;</span><br><span class="line">  auto a1 = x;</span><br><span class="line">  auto&amp;&amp; a2 = x;</span><br><span class="line">  auto&amp;&amp; a3 = 1;</span><br><span class="line">  func(a1); // 调用 void func(int&amp;)</span><br><span class="line">  func(a2); // 调用 void func(int&amp;)</span><br><span class="line">  func(a3); // 调用 void func(int&amp;&amp;)</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>左值引用接收左值，const左值引用4种全部都能接收，右值引用和const右值引用都只能接收右值</p>
</blockquote>
<h2 id="vector与list的区别与应用"><a href="#vector与list的区别与应用" class="headerlink" title="vector与list的区别与应用"></a>vector与list的区别与应用</h2><blockquote>
<p>vector随机访问效率高，但是插入删除节点，除了尾节点，效率低。list随机访问效率低，插入删除效率高。</p>
</blockquote>
<blockquote>
<p>迭代器是否失效，插入删除数据内存空间是否重新分配，内存是否发生移动。</p>
</blockquote>
<h2 id="vector扩容"><a href="#vector扩容" class="headerlink" title="vector扩容"></a>vector扩容</h2><blockquote>
<p>vs 1.5倍 gcc 2倍<br>倍数扩容常数时间复杂度，指定大小扩容o(n)复杂度<br>空间换时间</p>
</blockquote>
<h2 id="Vector如何释放空间"><a href="#Vector如何释放空间" class="headerlink" title="Vector如何释放空间?"></a>Vector如何释放空间?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt;(Vec).swap(Vec); //将Vec中多余内存清除； </span><br><span class="line">vector&lt;T&gt;().swap(Vec); //清空Vec的全部内存；</span><br><span class="line">size</span><br><span class="line">capacity</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="容器内部删除一个元素"><a href="#容器内部删除一个元素" class="headerlink" title="容器内部删除一个元素"></a>容器内部删除一个元素</h2><blockquote>
<p>序列式容器<br>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p>
</blockquote>
<pre><code>it=c.erase(it)
</code></pre>
<blockquote>
<p>关联式容器<br>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p>
</blockquote>
<pre><code>c.erase(it++)
</code></pre>
<h2 id="STL迭代器的五种属性"><a href="#STL迭代器的五种属性" class="headerlink" title="STL迭代器的五种属性"></a>STL迭代器的五种属性</h2><blockquote>
<p>不暴露容器结构的情况下对容器进行遍历以及充当容器和算法之前的粘合剂</p>
</blockquote>
<blockquote>
<p>value_type :迭代器所指向的对象的类型<br>difference_type：表示两个迭代器之间的距离<br>pointer：表示迭代器所指向的对象的指针类型<br>reference：表示迭代器所指向的对象的引用类型<br>iterator_category：表示迭代器的类型，可以分为五个类型：输入迭代器（input iterator）、输出迭代器（output iterator）、前向迭代器（forward iterator）、双向迭代器（bidirectional iterator）和随机访问迭代器（random access iterator）。其中，输入迭代器和输出迭代器只能单向遍历容器中的元素，前向迭代器和双向迭代器支持双向遍历容器中的元素，而随机访问迭代器则可以以任意顺序访问容器中的元素，并支持直接计算两个迭代器之间的距离。</p>
</blockquote>
<h2 id="map中-与find的区别？"><a href="#map中-与find的区别？" class="headerlink" title="map中[]与find的区别？"></a>map中[]与find的区别？</h2><blockquote>
<p>前者找到了返回value，没找到将key和默认value值插入<br>后者找到了返回指向key-value值的迭代器，没找到返回尾迭代器</p>
</blockquote>
<h2 id="STL空间配置器（一级配置器及二级配置器）"><a href="#STL空间配置器（一级配置器及二级配置器）" class="headerlink" title="STL空间配置器（一级配置器及二级配置器）"></a>STL空间配置器（一级配置器及二级配置器）</h2><blockquote>
<p>一级配置器直接调用malloc和free<br>SGI（STL的版本）的第一级配置器以malloc，free，realloc等C函数执行实际的内存配置，释放，重配置操作，当malloc或者realloc调用不成功时，改为调用malloc_alloc_oom_malloc或者malloc_alloc_oom_realloc，它<a href="">俩都有内循环，不</a>断调用，期望在某次调用之后，获得足够的内存，但是如果“内存不足的这个处理例程”未被客户端设定，则直接抛出bad_alloc异常，或者终止程序。<br><img src="https://img1.imgtp.com/2023/05/06/zDOOv5ZT.png" alt="image" loading="lazy"></p>
</blockquote>
<blockquote>
<p>二级配置器使用内存池+自由链表的形式避免了小块内存带来的碎片化，提高了内存分配的效率以及内存利用率。只有要申请的空间小于128bytes时才会调用二级空间配置器<br><img src="https://img1.imgtp.com/2023/05/06/fj10k6Po.png" alt="image" loading="lazy"></p>
</blockquote>
<blockquote>
<p>如果用户申请的内存大小不是8的倍数，二级配置器会将申请的字节数上调至距离用户申请大小的最近的8的倍数处。（这里带来了内碎片问题，和之前谈到的外碎片问题相比，这个问题我们无法避免）.</p>
</blockquote>
<blockquote>
<p>另外为什么内存块最小是八字节，之后以八字节为单位递增。是因为内存块以链表形式连接，最小需要存储一个指针的内存</p>
</blockquote>
<blockquote>
<p>申请内存，补8，free_list链表，内存池，malloc申请，一级空间配置器</p>
</blockquote>
<h2 id="STL中的allocator、deallocator"><a href="#STL中的allocator、deallocator" class="headerlink" title="STL中的allocator、deallocator"></a>STL中的allocator、deallocator</h2><blockquote>
<p>空间配置函数allocate(),空间释放函数deallocate()。否首先判断区块大小。然后大于128字节1级，小于就去找二级的free_list</p>
</blockquote>
<h2 id="STL之hashtable"><a href="#STL之hashtable" class="headerlink" title="STL之hashtable"></a>STL之hashtable</h2><blockquote>
<p>利用数组的查找快和链表的插入删除快</p>
</blockquote>
<blockquote>
<p>解决hash冲突，拉链法和线性探测法<br><img src="https://img1.imgtp.com/2023/05/06/UmVYagNN.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/06/VU5t5jWv.png" alt="image" loading="lazy"></p>
</blockquote>
<blockquote>
<p>负载因子等于1时进行扩容，容量2n+1<br>Redis中双hash,一次扩容，多次转移<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mfrbuaa/p/5245064.html">https://www.cnblogs.com/mfrbuaa/p/5245064.html</a></p>
</blockquote>
<h2 id="STL中每种容器对应的迭代器"><a href="#STL中每种容器对应的迭代器" class="headerlink" title="STL中每种容器对应的迭代器"></a>STL中每种容器对应的迭代器</h2><blockquote>
<p>random_access_iterator：随机访问迭代器</p>
</blockquote>
<ol>
<li>std::array 由于数组是连续空间，可以根据头指针偏移量来直接寻址</li>
<li>std::vector 动态数组容器由于是连续空间，类似数组，所以也可以根据头指针偏移量来直接寻址</li>
<li>std::deque 双向队列的内部实现其实是通过多个连续空间拼接而成的，所以也可以直接寻址</li>
</ol>
<blockquote>
<p>bidirectional_iterator:双向迭代器</p>
</blockquote>
<ol>
<li>std::list 列表的内部实现是双向链表，不是连续空间，因此只能使用指针逐一迭代间接寻址</li>
<li>std::set&#x2F;std::multiset 集合的内部实现是红黑树，红黑树是低度平衡二叉搜索树，每个节点保存了父节点和左右子节点的指针，所以可以通过指针逐一间接寻址</li>
<li>每个节点保存了父节点和左右子节点的指针，所以可以通过指针逐一间接寻址</li>
</ol>
<blockquote>
<p>forward_iterator</p>
</blockquote>
<ol>
<li>std::unordered_set&#x2F;std::unordered_multiset 无序集合（哈希集合）的内部实现是hashtable，hashtable是通过连续空间下的buckets（通常用vector实现）来散列存储元素，虽然是连续空间，但是实际上unordered容器的实现，每个bucket（node）的结构是这样的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Value&gt;</span><br><span class="line">struct __hashtable_node</span><br><span class="line">&#123;</span><br><span class="line">	__hashtable_node* next;</span><br><span class="line">	Value val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>std::unordered_map&#x2F;std::unordered_multimap 无序表（哈希表）的内部实现也是hashtable，同理</li>
<li>std::forward_list 单向列表的内部实现为单向链表，只支持单向迭代<br>val是bucket中的元素，next用于指向下一个node。这样设计的原因是解决hash冲突，这样冲突的元素会放在这样的一条单向链表中，所以实际上每一个bucket中的元素只能从前往后迭代，无法向前迭代</li>
</ol>
<h2 id="说说迭代器失效的情况"><a href="#说说迭代器失效的情况" class="headerlink" title="说说迭代器失效的情况"></a>说说迭代器失效的情况</h2><blockquote>
<p>分成三种数据类型考虑</p>
</blockquote>
<ol>
<li>数组型<br>内存结构改变的迭代器会全部失效。用iter &#x3D;XXX.erase(iter);直接返回下一个有用的迭代器</li>
<li>链表型<br>迭代器不会失效。erase(iter++)或者iter &#x3D;XXX.erase(iter).接着用就好</li>
<li>树型<br>只是当前失效。返回的是void,erase(iter++)</li>
</ol>
<h2 id="C-的多态如何实现"><a href="#C-的多态如何实现" class="headerlink" title="C++的多态如何实现"></a>C++的多态如何实现</h2><blockquote>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型通过虚表指针指向的虚表来调用相应的函数，如果对象类型是基类，就调用基类的函数，如果对象类型是派生类，就调用派生类的函数，但是如果派生类没有重写父类的虚函数就还是调用父类的函数。</p>
</blockquote>
<h2 id="构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h2><blockquote>
<p>析构函数可以被声明为虚函数，并且往往是必须的。可以被声明为纯虚函数，但是需要注意的必须在类外有它的定义体，因为析构函数的调用在子类中是隐含。</p>
</blockquote>
<blockquote>
<p>构造函数都不可以，调用虚函数必须通过虚表指针指向虚函数，但是构造函数不执行就没有虚表指针</p>
</blockquote>
<h2 id="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h2><blockquote>
<p>常量区<br>构造函数执行时，在对象内存布局的最前面</p>
</blockquote>
<h2 id="模板函数和模板类的特例化"><a href="#模板函数和模板类的特例化" class="headerlink" title="模板函数和模板类的特例化"></a>模板函数和模板类的特例化</h2><blockquote>
<p>引入原因<br>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
</blockquote>
<blockquote>
<p>模板函数特例化</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; //模板函数</span><br><span class="line">int compare(const T &amp;v1,const T &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">    if(v1 &gt; v2) return -1;</span><br><span class="line">    if(v2 &gt; v1) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span><br><span class="line">template&lt;&gt; </span><br><span class="line">int compare(const char* const &amp;v1,const char* const &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本质<br>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
</blockquote>
<blockquote>
<p>注意<br>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
</blockquote>
<blockquote>
<p>类模板特例化</p>
</blockquote>
<pre><code>template&lt;&gt;
class hash&lt;sales_data&gt;
&#123;
    size_t operator()(sales_data&amp; s);
    //里面所有T都换成特例化类型版本sales_data
    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
&#125;;
</code></pre>
<blockquote>
<p>类模板的部分特例化<br>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">    void Bar();</span><br><span class="line">    void Barst(T a)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">void Foo&lt;int&gt;::Bar()</span><br><span class="line">&#123;</span><br><span class="line">    //进行int类型的特例化处理</span><br><span class="line">    cout &lt;&lt; &quot;我是int型特例化&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;int&gt; fi;//使用特例化</span><br><span class="line">fs.Bar();//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span><br><span class="line">fi.Bar();//特例化版本，执行Foo&lt;int&gt;::Bar()</span><br><span class="line">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>对于模板，编译器会编译两次，一次是声明的时候，一次是模板参数被替换的时候</li>
</ul>
<h2 id="构造函数、析构函数、虚函数可否声明为内联函数"><a href="#构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="构造函数、析构函数、虚函数可否声明为内联函数"></a>构造函数、析构函数、虚函数可否声明为内联函数</h2><blockquote>
<p>可以，但是没有意义。inline、register只是一种建议，编译器不一定会真正的内联</p>
</blockquote>
<blockquote>
<p>构造、析构函数内部很复杂基本不会内联。虚函数动态类型是派生类不会，基类的话如果很简单的话也许会</p>
</blockquote>
<h2 id="构造函数和析构函数可以调用虚函数吗，为什么"><a href="#构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="构造函数和析构函数可以调用虚函数吗，为什么"></a>构造函数和析构函数可以调用虚函数吗，为什么</h2><blockquote>
<p>你可以调用，但是不推荐，可能不会达到预期效果<br>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。在构造函数中调用的虚函数都是实调用，你用普通函数一样可以实现。<br>（1）不要在构造函数中调用虚函数的原因：因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化， 因此调用子类的虚函数是不安全的，故而C++不会进行动态联编。<br>（2）不要在析构函数中调用虚函数的原因：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p>
</blockquote>
<h2 id="构造函数、析构函数的内部执行顺序？"><a href="#构造函数、析构函数的内部执行顺序？" class="headerlink" title="构造函数、析构函数的内部执行顺序？"></a>构造函数、析构函数的内部执行顺序？</h2><ul>
<li>构造函数<ul>
<li>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</li>
<li>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</li>
<li>派生类构造函数</li>
</ul>
</li>
<li>析构函数<ul>
<li>调用派生类的析构函数</li>
<li>调用成员类对象的析构函数</li>
<li>调用基类的析构函数</li>
</ul>
</li>
</ul>
<h2 id="构造函数析构函数可否抛出异常"><a href="#构造函数析构函数可否抛出异常" class="headerlink" title="构造函数析构函数可否抛出异常"></a>构造函数析构函数可否抛出异常</h2><blockquote>
<p>都可以抛出，但是都不建议使用，很危险<br>构造函数抛出异常，对应析构函数不调用。如果构造函数跑异常前分配了内存，内存泄露。<br>析构函数抛异常，函数跳出，释放内存，因为一个异常产生另一个异常，不可以这样做。</p>
</blockquote>
<h2 id="构造函数的几种关键字"><a href="#构造函数的几种关键字" class="headerlink" title="构造函数的几种关键字"></a>构造函数的几种关键字</h2><blockquote>
<p>default 声明一下，编译器自动生成 只适用于默认函数</p>
<p>&#x20;delete 禁止使用 包括new<br>0 纯虚函数 抽象类 如果会被调用 记得定义 类内外都可以</p>
</blockquote>
<h2 id="虚函数单一继承虚表布局-成员变量-虚函数-虚函数覆盖"><a href="#虚函数单一继承虚表布局-成员变量-虚函数-虚函数覆盖" class="headerlink" title="虚函数单一继承虚表布局(成员变量+虚函数+虚函数覆盖)"></a>虚函数单一继承虚表布局(成员变量+虚函数+虚函数覆盖)</h2><p><img src="https://img1.imgtp.com/2023/05/07/j7RXUEKe.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/TTFdUe3k.png" alt="image" loading="lazy"></p>
<h2 id="虚函数多继承虚表布局-成员变量-虚函数-虚函数覆盖"><a href="#虚函数多继承虚表布局-成员变量-虚函数-虚函数覆盖" class="headerlink" title="虚函数多继承虚表布局(成员变量+虚函数+虚函数覆盖)"></a>虚函数多继承虚表布局(成员变量+虚函数+虚函数覆盖)</h2><p><img src="https://img1.imgtp.com/2023/05/07/KHmZm14C.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/1UaGARXF.png" alt="image" loading="lazy"></p>
<h2 id="虚函数深度为2的继承-多继承后再单继承-虚表布局-成员变量-虚函数-虚函数覆盖"><a href="#虚函数深度为2的继承-多继承后再单继承-虚表布局-成员变量-虚函数-虚函数覆盖" class="headerlink" title="虚函数深度为2的继承(多继承后再单继承)虚表布局(成员变量+虚函数+虚函数覆盖)"></a>虚函数深度为2的继承(多继承后再单继承)虚表布局(成员变量+虚函数+虚函数覆盖)</h2><p><img src="https://img1.imgtp.com/2023/05/07/H9yeaUWQ.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/jwXna1wn.png" alt="image" loading="lazy"></p>
<h2 id="虚函数重复继承虚表布局-成员变量-虚函数-虚函数覆盖"><a href="#虚函数重复继承虚表布局-成员变量-虚函数-虚函数覆盖" class="headerlink" title="虚函数重复继承虚表布局(成员变量+虚函数+虚函数覆盖)"></a>虚函数重复继承虚表布局(成员变量+虚函数+虚函数覆盖)</h2><p><img src="https://img1.imgtp.com/2023/05/07/W2luJC77.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/qemv9jfo.png" alt="image" loading="lazy"></p>
<h2 id="x20-虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的"><a href="#x20-虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的" class="headerlink" title="&#x20;虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的"></a>&#x20;虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的</h2><h2 id="vftptr-虚函数指针-指向虚函数表-vbptr-虚基类指针-指向虚基类表"><a href="#vftptr-虚函数指针-指向虚函数表-vbptr-虚基类指针-指向虚基类表" class="headerlink" title="vftptr 虚函数指针 指向虚函数表 vbptr 虚基类指针 指向虚基类表"></a>vftptr 虚函数指针 指向虚函数表 vbptr 虚基类指针 指向虚基类表</h2><h2 id="虚继承下的单一继承以及派生类全重载的虚函数指针无大小"><a href="#虚继承下的单一继承以及派生类全重载的虚函数指针无大小" class="headerlink" title="虚继承下的单一继承以及派生类全重载的虚函数指针无大小"></a>虚继承下的单一继承以及派生类全重载的虚函数指针无大小</h2><p><img src="https://img1.imgtp.com/2023/05/07/SPnniiBI.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/2mFrr1aC.png" alt="image" loading="lazy"></p>
<h2 id="虚继承下的多继承，既有虚继承又存在一般继承中一般继承在前"><a href="#虚继承下的多继承，既有虚继承又存在一般继承中一般继承在前" class="headerlink" title="虚继承下的多继承，既有虚继承又存在一般继承中一般继承在前"></a>虚继承下的多继承，既有虚继承又存在一般继承中一般继承在前</h2><p><img src="https://img1.imgtp.com/2023/05/07/j9ZrSL3r.png" alt="image" loading="lazy"></p>
<blockquote>
<p>还有一种相反的情况</p>
</blockquote>
<p><img src="https://img1.imgtp.com/2023/05/07/AdNzw6LJ.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/VLNGG8tr.png" alt="image" loading="lazy"></p>
<h2 id="虚继承下的多继承全部虚继承"><a href="#虚继承下的多继承全部虚继承" class="headerlink" title="虚继承下的多继承全部虚继承"></a>虚继承下的多继承全部虚继承</h2><p><img src="https://img1.imgtp.com/2023/05/07/XZrQaKJD.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/GQkExGR7.png" alt="image" loading="lazy"></p>
<h2 id="钻石型的虚拟多重继承-含成员变量-虚函数-虚函数覆盖"><a href="#钻石型的虚拟多重继承-含成员变量-虚函数-虚函数覆盖" class="headerlink" title="钻石型的虚拟多重继承(含成员变量+虚函数+虚函数覆盖)"></a>钻石型的虚拟多重继承(含成员变量+虚函数+虚函数覆盖)</h2><p><img src="https://img1.imgtp.com/2023/05/07/5HQhXOK7.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/07/bJokf2kP.png" alt="image" loading="lazy"></p>
<h2 id="c-11线程方面的内存模型"><a href="#c-11线程方面的内存模型" class="headerlink" title="c++11线程方面的内存模型"></a>c++11线程方面的内存模型</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d6b1f93d92c8">https://www.jianshu.com/p/d6b1f93d92c8</a></p>
<h2 id="什么情况下编辑器自动生成默认的构造函数？"><a href="#什么情况下编辑器自动生成默认的构造函数？" class="headerlink" title="什么情况下编辑器自动生成默认的构造函数？"></a>什么情况下编辑器自动生成默认的构造函数？</h2><blockquote>
<p>首先生成的默认构造函数只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。内置类型都被赋予了一个随机值，可能会出现问题。</p>
</blockquote>
<blockquote>
<p>另外不是你没有显式定义的时候生成默认构造函数。而是只有默认构造函数”被需要“的时候编译器才会生成默认构造函数</p>
</blockquote>
<ul>
<li>含有类对象数据成员，该类对象类型有默认构造函数</li>
<li>基类带有默认构造函数的派生类</li>
<li>带有虚函数的类</li>
<li>虚拟继承下</li>
<li></li>
</ul>
<h2 id="那什么时候需要合成拷贝构造函数呢？"><a href="#那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="那什么时候需要合成拷贝构造函数呢？"></a>那什么时候需要合成拷贝构造函数呢？</h2><h2 id="抽象基类为什么不能创建对象？"><a href="#抽象基类为什么不能创建对象？" class="headerlink" title="抽象基类为什么不能创建对象？"></a>抽象基类为什么不能创建对象？</h2><blockquote>
<p>在设计逻辑上被设计为不允许创建对象进行实例化。例如我们有一个动物的抽象基类，纯虚函数是动作，成员变量是体重。我们用一个狗类继承它然后定义动作“正在刨坑”，体重80.后者是合理的，前者是不合理的。</p>
</blockquote>
<h2 id="为什么拷贝构造函数必须传引用不能传值？"><a href="#为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="为什么拷贝构造函数必须传引用不能传值？"></a>为什么拷贝构造函数必须传引用不能传值？</h2><blockquote>
<p>传递的实参是类的实例化对象，如果传值实参赋值给形参又会调用拷贝构造函数，然后无限递归</p>
</blockquote>
<h2 id="静态函数能定义为虚函数吗？常函数呢？说说你的理解"><a href="#静态函数能定义为虚函数吗？常函数呢？说说你的理解" class="headerlink" title="静态函数能定义为虚函数吗？常函数呢？说说你的理解"></a>静态函数能定义为虚函数吗？常函数呢？说说你的理解</h2><blockquote>
<p>都不可以，因为static没有this指针<br>没有this指针就无法通过this-&gt;vftptr-&gt;vtable -&gt;virtual function<br>const函数无法改变成员变量就是因为this指针从顶层指针变为底层和顶层指针，但是static没有this指针</p>
</blockquote>
<h2 id="哪些函数不能是虚函数？把你知道的都说一说"><a href="#哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="哪些函数不能是虚函数？把你知道的都说一说"></a>哪些函数不能是虚函数？把你知道的都说一说</h2><blockquote>
<p>静态成员函数<br>构造函数<br>友元函数<br>内联成员函数</p>
</blockquote>
<h2 id="什么是纯虚函数，与虚函数的区别"><a href="#什么是纯虚函数，与虚函数的区别" class="headerlink" title="什么是纯虚函数，与虚函数的区别"></a>什么是纯虚函数，与虚函数的区别</h2><blockquote>
<p>定义方式和使用方式</p>
</blockquote>
<h2 id="x20-内存池"><a href="#x20-内存池" class="headerlink" title="&#x20;内存池"></a>&#x20;内存池</h2><blockquote>
<p>内存池则是在真正使用内存之前，先申请分配一大块内存（内存池）留作备用。当程序员申请内存时，从池中取出一块动态分配，当程序员释放时，将释放的内存放回到池内，再次申请，就可以从池里取出来使用，有需要就与周边的空闲内存块合并。若内存池不够时，则自动扩大内存池，从操作系统中申请更大的内存池。\</p>
</blockquote>
<blockquote>
<p>缓解内存碎片的问题。提高内存的申请分配效率</p>
</blockquote>
<h2 id="x20-连接池"><a href="#x20-连接池" class="headerlink" title="&#x20;连接池"></a>&#x20;连接池</h2><blockquote>
<p>连接池就是在申请连接之前就申请好了一些连接做备用。给任何需要它的线程使用，需要就直接用，不需要就放回去</p>
</blockquote>
<blockquote>
<p>解决重复申请连接，关闭连接的开销</p>
</blockquote>
<h2 id="检测内存泄露"><a href="#检测内存泄露" class="headerlink" title="检测内存泄露"></a>检测内存泄露</h2><blockquote>
<p>windows   vs调试器和 运行时(CRT)运行时库 对比分配内存 释放内存<br>开头两行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span>  CRTDBG_MAP_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>return 前一行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_CrtDumpMemoryLeaks()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>linux Valgrind</p>
</blockquote>
<h2 id="内存泄露危害"><a href="#内存泄露危害" class="headerlink" title="内存泄露危害"></a>内存泄露危害</h2><blockquote>
<p>内存不释放，内存耗尽<br>碎片太多，性能下降<br>系统崩溃<br>暴露内存数据，有安全漏洞</p>
</blockquote>
<h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><blockquote>
<p>C++ 异常处理是一种在程序运行过程中出现异常情况时，能够使程序在异常发生地点转移控制到另一个代码块以处理异常的机制。通过使用异常处理，可以使程序在出现问题时不至于崩溃，并且能够在发生异常时采取正确的处理措施，保证程序的稳定性和可靠性。<br>try throw catch</p>
</blockquote>
<h2 id="常见异常类型"><a href="#常见异常类型" class="headerlink" title="常见异常类型"></a>常见异常类型</h2><blockquote>
<p>bad_typeid<br>在使用typeid运算符时，如果其操作数是一个多态类型的指针，而该指针的值为NULL时，则会抛出异常。</p>
</blockquote>
<blockquote>
<p>bad_cast<br>在使用dynamic_cast()进行从多态基类对象（或引用）到派生类对象（或引用）的强制类型转化时，如果类型是不安全的，则会抛出异常</p>
</blockquote>
<blockquote>
<p>bad_alloc<br>这个是最熟悉的：在使用new运算符进行动态内存分配时，如果没有足够的空间可分配，则会引发此类异常</p>
</blockquote>
<blockquote>
<p>out_of_range<br>数组字符串等下标越界，抛出访问越界异常</p>
</blockquote>
<blockquote>
<p>length_error<br>表明当一个程序试图产生一个比npos长度还要大的对象</p>
</blockquote>
<blockquote>
<p>runtime_error<br>从基类（exception）中派生，报告运行时错误，只有在程序运行时，这类错误才会被检测到。<br>）</p>
</blockquote>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority queue"></a>priority queue</h2><blockquote>
<p>任务调度，数据优先级排序</p>
</blockquote>
<blockquote>
<p>top()  ：返回元素中第一个元素的引用（优先级最高的元素都会被放到顶部，既第一个元素）.<br>push()：插入一个元素，并重新维护堆，无返回值.<br>pop() ：删除优先级最高的元素，并重新维护堆无返回值<br>size() ：返回容器中有效元素的数量，返回队列的大小<br>empty() ：检测容器是否为空.返回“true”或者“false”.</p>
</blockquote>
<ul>
<li>内置类型<br><img src="https://img1.imgtp.com/2023/05/12/dJpKcEqA.png" alt="image" loading="lazy"></li>
<li>自定义类型<br><img src="https://img1.imgtp.com/2023/05/12/febTSFKN.png" alt="image" loading="lazy"><br><img src="https://img1.imgtp.com/2023/05/12/vgefrAem.png" alt="image" loading="lazy"></li>
</ul>
<h2 id="移动构造和拷贝构造的区别"><a href="#移动构造和拷贝构造的区别" class="headerlink" title="移动构造和拷贝构造的区别"></a>移动构造和拷贝构造的区别</h2><blockquote>
<p>：移动构造函数是c++11的新特性，移动构造函数传入的参数是一个右值 用&amp;&amp;标出。一般来说左值可以通过使用std:move方法强制转换为右值。首先讲讲拷贝构造函数：拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间。而移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。</p>
</blockquote>
<h2 id="右值引用与左值引用的区别"><a href="#右值引用与左值引用的区别" class="headerlink" title="右值引用与左值引用的区别"></a>右值引用与左值引用的区别</h2><blockquote>
<p>（1）左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象依然存在；右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后就对象就会被销毁。<br>（2）左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。</p>
</blockquote>
<h2 id="引入右值的原因"><a href="#引入右值的原因" class="headerlink" title="引入右值的原因"></a>引入右值的原因</h2><blockquote>
<p>移动构造函数</p>
</blockquote>
<blockquote>
<p>移动含有不能共享资源的类对象<br>unique_ptr</p>
</blockquote>
<h2 id="C-11的std-function和std-bind"><a href="#C-11的std-function和std-bind" class="headerlink" title="C++11的std::function和std::bind"></a>C++11的std::function和std::bind</h2><blockquote>
<p>函数，函数指针，lambda函数，bind对象，函数对象【重载了函数调用运算符()的类的对象，即为函数对象。】。由于可调用对象的定义方式比较多，但是函数的调用方式较为类似，因此需要使用一个统一的方式保存可调用对象或者传递可调用对象。于是，std::function就诞生了。<br>容纳除了类成员函数指针以外的所有可调用对象，通过一种统一的方式使用他们。用bind解决了类成员函数指针的问题。</p>
</blockquote>
<blockquote>
<p>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，这是因为对象的成员函数需要有this指针。并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&amp;手动转换；</p>
</blockquote>
<blockquote>
<p>预绑定的参数是以值传递的形式，不预绑定的参数要用std::placeholders(占位符)的形式占位，从_1开始，依次递增，是以引用传递的形式；</p>
</blockquote>
<blockquote>
<p>std::placeholders表示新的可调用对象的第几个参数，而且与原函数的该占位符所在位置的进行匹配；</p>
</blockquote>
<blockquote>
<p>std::bind的返回值是可调用实体，可以直接赋给std::function</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38410730/article/details/103637778">https://blog.csdn.net/qq_38410730/article/details/103637778</a></p>
<h2 id="foeward完美转发"><a href="#foeward完美转发" class="headerlink" title="foeward完美转发"></a>foeward完美转发</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangbaohui/article/details/103673177">https://blog.csdn.net/xiangbaohui/article/details/103673177</a></p>
</blockquote>
<h2 id="c-语言级别的多线程"><a href="#c-语言级别的多线程" class="headerlink" title="c++语言级别的多线程"></a>c++语言级别的多线程</h2><p>std::mutex std::condition variable .wait()等待、阻塞、获得锁 .notify_all()</p>
<blockquote>
<p>线程同步之线程互斥</p>
</blockquote>
<ol>
<li>临界区代码段长一点就用lock_guard()</li>
<li>只有一个变量就CAS无锁机制，atomic原子类型</li>
</ol>
<blockquote>
<p>线程同步之线程通信</p>
</blockquote>
<ol>
<li>条件变量+unique_lock()</li>
<li>信号量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as Alice</span><br><span class="line">    participant J as John</span><br><span class="line">    A-&gt;&gt;J: Hello John, how are you?</span><br><span class="line">    J-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/640260248">https://zhuanlan.zhihu.com/p/640260248</a></p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>bbkkp</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://bbkkp.github.io/2024/08/31/C++%20eight-part%20text.html/" title="C++八股文">https://bbkkp.github.io/2024/08/31/C++%20eight-part%20text.html/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2024/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87.html/" rel="prev" title="STL操作系统八股文"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">STL操作系统八股文</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2024/08/31/STL.html/" rel="next" title="STL"><span class="post-nav-text">STL</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2024 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> bbkkp</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div><div class="live-time"><span>感谢陪伴</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2024-08-30T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div><div class="footer-custom-text"><a href="yourLink" rel="noopener" target="_blank">学就完了</a></div><div class="footer-support"><span>本站由</span><a class="footer-support-logo" href="https://www.rainyun.com/YeMeng_" target="blank" title="雨云"><img height="30" src="https://cn-sy1.rains3.com/yemenghexo/rainyunlogo.png" alt="雨云"></a><span>提供 对象存储 服务</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>